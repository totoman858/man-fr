Content-type: text/html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of MLOCKALL</TITLE>
</HEAD><BODY>
<H1>MLOCKALL</H1>
Section: Manuel du programmeur Linux (2)<BR>Updated: 18 juillet 2003<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NOM</H2>

mlockall - Désactiver la pagination pour le processus appelant.
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#include &lt;<A HREF="file:///usr/include/sys/mman.h">sys/mman.h</A>&gt;</B>

<B>int mlockall(int </B><I>flags</I><B>);
</B></PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<B>mlockall</B>

désactive la pagination pour toutes les pages présentes dans l'espace d'adressage
du processus appelant. Ceci inclut les pages de code, de données, et la pile,
tout autant que les bibliothèques partagées, les données utilisateur dans le
noyau, la mémoire partagée et les fichiers projetés en mémoire. Quand l'appel
<B>mlockall</B>

réussit, on a l'assurance que toutes les pages concernées résident en mémoire
vive (RAM) et y resteront jusqu'à un déverrouillage par la fonction
<B>munlock</B>

ou
<B>munlockall</B>

ou encore jusqu'à ce que le processus se termine ou démarre
un programme avec
<B>exec</B>.

Les processus fils n'héritent pas du verrouillage des pages
à travers un
<B>fork</B>.

<P>
Il y a deux domaines principaux d'applications au verrouillage de pages&nbsp;:
les algorithmes en temps réel, et le traitement de données confidentielles.
Les applications temps réel réclament un comportement temporel
déterministe, et la pagination est, avec l'ordonnancement, une
cause majeure de délais imprévus.
Ces algorithmes basculent habituellement sur un ordonnancement temps réel avec
<B>sched_setscheduler.</B>

Les logiciels de cryptographie manipulent souvent quelques
octets hautement confidentiels, comme des mots de passe ou
des clés privées. A cause de la pagination ces données secrètes
risquent d'être transférées sur un support physique où elles
pourraient être lues par un ennemi longtemps après que le
logiciel se soit terminé.
Néanmoins pour les applications sécurisées, seule une petite
partie de la mémoire doit être verrouillée, pour laquelle la
fonction
<B>mlock</B>

est parfaitement appropriée.
<P>
Le paramètre
<I>flags</I>

est constitué par un
<I>OU binaire</I>

( | ) entre les constantes symboliques suivantes :
<DL COMPACT>
<DT><B>MCL_CURRENT</B>

<DD>
Verrouiller toutes les pages correspondant actuellement à l'espace
d'adressage du processus.
<DT><B>MCL_FUTUR</B>

<DD>
Verrouiller toutes les pages qui seront dans l'espace d'adressage
du processus dans le futur. Ceci concerne par exemple les nouvelles
pages réclamées par un agrandissement de la pile ou du tas, autant
que les nouveaux fichier projetés en mémoire, ou les nouvelles
régions de mémoire partagée.
</DL>
<P>

Si
<B>MCL_FUTUR</B>

a été réclamé, et que le nombre de pages verrouillées
excède la limite maximale, l'appel système ayant entraîné le
dépassement échouera avec une erreur
<B>ENOMEM.</B>

Si le problème se pose à cause de l'expansion de la pile, le noyau
empêchera l'agrandissement de celle-ci et déclenchera un signal
<B>SIGSEGV.</B>

<P>
Les processus temps-réel doivent réserver suffisamment de pages
avant d'entrer dans des portions critiques, pour éviter tout
déclenchement de faute de page.
Ceci peut être effectué simplement en appelant une fonction
réclamant une variable automatique suffisamment grande, et qui
écrit dans cette variable de manière à allouer ces pages pour
la pile.
L'écriture dans la variable garantit qu'il ne se produira même pas
de faute de page de copie-sur-écriture durant l'exécution de la 
section critique.
<P>
Il n'y a pas d'empilement des verrouillages mémoire, ce qui
signifie qu'une page verrouillée plusieurs fois par
<B>mlock</B>

ou
<B>mlockall</B>

sera libérée en un seul appel à
<B>munlock</B>

pour la zone mémoire correspondante ou par un appel à
<B>munlockall.</B>

Les pages qui sont verrouillées par plusieurs zones, ou
par plusieurs processus restent en mémoire vive tant qu'il
y a au moins un processus ou une zone qui les verrouille.
<P>
Sur les systèmes POSIX où
<B>mlockall</B>

et
<B>munlockall</B>

sont disponibles, la constante symbolique
<B>_POSIX_MEMLOCK</B>

est définie dans &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;
<A NAME="lbAE">&nbsp;</A>
<H2>VALEUR RENVOYÉE</H2>

<B>mlockall</B>

renvoie 0 si il réussit, ou -1 s'il échoue, auquel cas
<I>errno</I>

contient le code d'erreur.
<A NAME="lbAF">&nbsp;</A>
<H2>ERREURS</H2>

<DL COMPACT>
<DT><B>ENOMEM</B>

<DD>
Le processus a dépassé le nombre maximal de page verrouillées.
<DT><B>EPERM</B>

<DD>
L'appelant n'a pas les privilèges appropriés, seul le Super-User 
peut verrouiller des pages.
<DT><B>EINVAL</B>

<DD>
Un attribut inconnu a été spécifié.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>CONFORMITÉ</H2>

POSIX.1b, SVr4. SVr4 documente un code d'erreur EAGAIN supplémentaire.
<A NAME="lbAH">&nbsp;</A>
<H2>VOIR AUSSI</H2>

<B><A HREF="/cgi-bin/man/man2html?2+munlockall">munlockall</A>(2)</B>,

<B><A HREF="/cgi-bin/man/man2html?2+mlock">mlock</A>(2)</B>,

<B><A HREF="/cgi-bin/man/man2html?2+munlock">munlock</A>(2)</B>

<A NAME="lbAI">&nbsp;</A>
<H2>TRADUCTION</H2>

Christophe Blaess, 1996-2003.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NOM</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">VALEUR RENVOYÉE</A><DD>
<DT><A HREF="#lbAF">ERREURS</A><DD>
<DT><A HREF="#lbAG">CONFORMITÉ</A><DD>
<DT><A HREF="#lbAH">VOIR AUSSI</A><DD>
<DT><A HREF="#lbAI">TRADUCTION</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 14:54:51 GMT, February 11, 2014
</BODY>
</HTML>
