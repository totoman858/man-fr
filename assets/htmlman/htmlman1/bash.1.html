Content-type: text/html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of BASH</TITLE>
</HEAD><BODY>
<H1>BASH</H1>
Section: Manuel de l'utilisateur Linux (1)<BR>Updated: 20 Janvier 1999<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>



















<A NAME="lbAB">&nbsp;</A>
<H2>NOM</H2>

bash - Interpréteur de commandes GNU Bourne-Again SHell.
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<B>bash</B>

[options]
[fichier]
<A NAME="lbAD">&nbsp;</A>
<H2>COPYRIGHT</H2>

Bash est sous Copyright (C) 1989, 1999 de la Free Software Foundation, Inc.

<A NAME="lbAE">&nbsp;</A>
<H2>DESCRIPTION</H2>

<B>Bash</B>

est un interpréteur (<I>Shell</I>) compatible <B>sh</B> qui exécute les commandes
lues depuis l'entrée standard, ou depuis un fichier.
<B>Bash</B>

incorpore également des fonctionnalités provenant des interpréteurs <I>Korn</I>
et <I>C</I>-shell (<B>ksh</B> et <B>csh</B>).
<P>

<B>Bash</B>

est conçu pour être conforme aux spécifications IEEE concernant
les shells et les outils Posix (Groupe de travail de l'IEEE 1003.2).
<A NAME="lbAF">&nbsp;</A>
<H2>OPTIONS</H2>

En plus des caractères d'options documentés dans la description de la
commande interne <B>set</B>, <B>bash</B> accepte les arguments suivants
lorsqu'on l'invoque :
<P>


<DL COMPACT>
<DT><B>-c</B><I> chaîne</I>

<DD>
Si l'argument
<B>-c</B>

est présent, les commandes sont interprétées depuis la
<I>chaîne</I>

fournie. S'il existe d'autres arguments après la
<I>chaîne</I>,

ils sont transmis comme paramètres positionnels, en commençant par
<B>$0</B>.

<DT><B>-r</B>

<DD>
Si l'option
<B>-r</B>

est présente, l'interpréteur est
<I>restreint</I>

(voir
<FONT SIZE="-1"><B>SHELLS RESTREINTS</B>

</FONT>
plus bas). 
<DT><B>-i</B>

<DD>
Si l'option
<B>-i</B>

est présente, l'interpréteur est
<I>interactif</I>.

<DT><B>-s</B>

<DD>
Si l'option
<B>-s</B>

est présente, ou s'il n'y a plus d'arguments sur la ligne de commande, après
le traitement des options, l'interprétation se fera depuis l'entrée standard.
Cette option permet de remplir les paramètres positionnels tout en
invoquant un shell interactif.
<DT><B>-D</B>

<DD>
Une liste de toutes les chaînes entre '&quot;' et précédées de <B>$</B>
est affichée sur la sortie standard. Ce sont les chaînes qui sont
sujettes à une traduction quand la localisation n'est 
ni celle du C,
ni celle du standard POSIX.
Cela nécessite l'option <B>-n</B> ; aucune commande ne sera exécutée.
<DT><B>--</B>

<DD>
Deux caractères
<B>--</B>

permettent d'indiquer la fin des options, et empêchent le traitement
des arguments restants. Ces derniers sont alors traités
comme des noms
de fichiers et des paramètres.
<B>-</B>

est équivalent à <B>--</B>.

</DL>
<P>

<B>Bash</B>

reconnaît également plusieurs options multi-caractères. Ces options doivent,
pour être reconnues, apparaître sur la ligne de commande avant les
options mono-caractère.
<P>


<DL COMPACT>
<DT><B>--dump-po-strings</B>

<DD>
Équivalent à -D, mais la sortie est dans le format des fichiers <B>po</B>
(objets portables) de l'outil Gnu <I>gettext</I>.
<DT><B>--dump-strings</B>

<DD>
Équivalent à <B>-D</B>.
<DT><B>--help</B>

<DD>
Affiche un message d'aide sur la sortie standard et se termine avec succès.
<DT><B>--login</B>

<DD>
Demande que
<B>bash</B>

Se comporte comme un shell de login. (Voir
<FONT SIZE="-1"><B>INVOCATION</B>

</FONT>
plus bas).
<DT><B>--noediting</B>

<DD>
Ne pas utiliser la bibliothèque GNU
<I>readline</I>

pour la lecture des lignes de commande, lorsque le shell est interactif.
<DT><B>--noprofile</B>

<DD>
Ne lire ni le fichier de configuration générale

<I>/etc/profile</I>

ni les fichiers personnalisés
<I>~/.bash_profile</I>,

<I>~/.bash_login</I>,

ou
<I>~/.profile</I>.

Par défaut
<B>bash</B>

lit ces fichiers lorsqu'il est invoqué comme shell de login (voir le paragraphe
<FONT SIZE="-1"><B>INVOCATION</B>

</FONT>
plus bas).
<DT><B>-norc</B>

<DD>
Ne pas lire le fichier de configuration personnalisée
<I>~/.bashrc</I>

lorsque le shell est interactif.
Cette option est activée par défaut lorsque <B>bash</B> est invoqué sous le nom
<B>sh</B>.

<DT><B>--posix</B>

<DD>
Aligner le comportement de <B>bash</B> sur le standard Posix 1003.2, en ce qui
concerne les options dont l'action par défaut diffère de ce standard.
<DT><B>--rcfile</B> <I>fichier</I><DD>
Exécuter les commandes contenues dans le
<I>fichier</I>

mentionne, plutôt que celles du fichier de configuration personnelle
<I>~/.bashrc</I>,

si le shell est interactif (voir le paragraphe
<FONT SIZE="-1"><B>INVOCATION</B>

</FONT>
plus bas).
<DT><B>--restricted</B>

<DD>
Le shell devient restreint (voir le paragraphe
<FONT SIZE="-1"><B>SHELLS RESTREINTS</B>

</FONT>
plus bas).
<DT><B>--rpm-requires</B>

<DD>
Affiche une liste des fichiers qui sont nécessaires pour le lancement
d'un script shell. Ceci nécessite l'option '-n' et est soumis aux mêmes
limites que les vérifications d'erreurs à la compilation ; les back-quotes,
les tests [] et les évalutations ne sont pas analysés, et certaines erreurs
peuvent être oubliées.
<DT><B>--verbose</B>

<DD>
Équivalent à <B>-v</B>
<DT><B>--version</B>

<DD>
Afficher le numéro de version de
<B>bash</B>

sur la sortie standard et terminer avec succès.

</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>ARGUMENTS</H2>

S'il reste des arguments sur la ligne de commande après l'analyse des options,
et si ni l'option
<B>-c</B>,

ni l'option
<B>-s</B>

ne sont présentes, le premier argument est supposé être le nom du fichier dans
lequel lire les commandes. Lorsque 
<B>bash</B>

est invoqué de cette manière,
<B>$0</B>

contient le nom du fichier, et les autres paramètres positionnels contiennent
les arguments restants.
<B>Bash</B>

lit, et exécute, les commandes depuis ce fichier, puis se termine.
Le code de retour de <B>bash</B> est celui de la dernière commande
exécutée dans le fichier script.
Si aucune commande n'a été exécutée, le code de retour est 0.
<A NAME="lbAH">&nbsp;</A>
<H2>INVOCATION</H2>

Un shell est dit <I>de login</I> si le premier caractère de son argument numéro
zéro est un
<B>-</B>,

ou s'il est invoqué avec l'option
<B>-login</B>.

<P>

Un shell est <I>interactif</I> si son entrée standard et sa sortie standard sont
toutes deux connectées à un terminal (déterminé par la fonction
<I><A HREF="/cgi-bin/man/man2html?3+isatty">isatty</A></I>(3)),

ou s'il est invoqué avec l'option
<B>-i</B>.

Le paramètre
<FONT SIZE="-1"><B>PS1</B>

</FONT>
est positionné, et le paramètre
<B>$-</B>

contient la lettre
<B>i</B>

si
<B>bash</B>

est interactif, ce qui permet à un script ou à un fichier de démarrage de
vérifier l'état du shell.
<P>

Le paragraphe suivant décrit comment
<B>bash</B>

exécute ses fichiers d'initialisation.
Si l'un de ces fichiers existe mais n'est pas accessible en lecture,
<B>bash</B>

signale une erreur.
Les tildes sont remplacées par des noms de fichiers comme décrit dans
le paragraphe
<B>Développement du Tilde</B>

de la section
<FONT SIZE="-1"><B>Développement.</B>

</FONT>
<P>

Lorsque
<B>bash</B>

est lancé comme shell de login interactif, ou comme shell non-interactif avec
l'option <B>--login</B>, il lit et exécute tout d'abord les commandes
se trouvant dans le fichier <I>/etc/profile</I> s'il
existe.
Après lecture de ce fichier, il recherche <I>~/.bash_profile</I>,
<I>~/.bash_login</I>, et <I>~/.profile</I>, dans cet ordre, et exécute les
commande se trouvant dans le premier fichier existant et accessible en lecture.
L'option
<B>--noprofile</B>

peut être utilisée au démarrage du shell pour empêcher ce comportement.
<P>

Lorsqu'un shell de login se termine,
<B>bash</B>

lit et exécute les commandes du fichier <I>~/.bash_logout</I>, s'il
existe.
<P>

Quand un shell interactif démarre sans être un shell de login,
<B>bash</B>

lit et exécute les commandes se trouvant dans <I>~/.bashrc</I> s'il existe.
Ce comportement peut être inhibé à l'aide de
l'option
<B>--norc</B>.

L'option <B>--rcfile</B> <I>fichier</I> forcera
<B>bash</B>

à exécuter les commandes dans <I>fichier</I> plutôt que dans <I>~/.bashrc</I>.
<P>

Quand
<B>bash</B>

est démarré de manière non-interactive, pour lancer un script shell par exemple,
il recherche la variable
<FONT SIZE="-1"><B>BASH_ENV</B>

</FONT>
dans l'environnement, développe son contenu si elle existe, et considère cette
valeur comme le nom d'un fichier à lire et exécuter.
<B>Bash</B>

se comporte comme si la commande suivante se trouvait en début de script :
<P>
<DL COMPACT><DT><DD>
<TT>if [ -n &quot;$BASH_ENV&quot; ]; then . &quot;$BASH_ENV&quot;; fi</TT>
</DL>

<P>
mais la valeur de la variable
<FONT SIZE="-1"><B>PATH</B>

</FONT>
n'est pas utilisée pour rechercher le fichier.
<P>

Si 
<B>bash</B>

est invoqué sous le nom
<B>sh</B>,

il essaye d'imiter le comportement de démarrage des versions historiques de
<B>sh</B>

autant que possible, tout en restant
conforme au standard Posix. Lorsqu'il est invoqué comme shell de
login interactif (ou non-interactif avec l'option <B>--login</B>), il
essaye d'abord d'exécuter les commandes 
se trouvant dans
<I>/etc/profile</I>

et
<I>~/.profile</I>,

dans cet ordre.
L'option
<B>-noprofile</B>

peut toujours être utilisée pour désactiver ce comportement.
Quand il est invoqué en tant que shell interactif sous le nom
<B>sh</B>,

<B>bash</B>

consulte la variable
<FONT SIZE="-1"><B>ENV</B>,

</FONT>
développe sa valeur si elle est définie et utilise le résultat en tant que
nom de fichier à lire et exécuter.
Comme un shell invoqué sous le nom
<B>sh</B>

n'essaye pas d'exécuter d'autre fichier de démarrage,
l'option
<B>--rcfile</B>

n'a aucun effet.
Un shell non interactif invoqué sous le nom
<B>sh</B>

ne lit aucun autre fichier d'initialisation.
Quand il est invoqué sous le nom
<B>sh</B>,

<B>bash</B>

entre en mode
<I>posix</I>

après avoir lu les fichiers d'initialisation.
<P>

Quand
<B>bash </B>

est invoqué en mode
<I>posix</I>,

avec l'option
<B>-posix</B>

sur la ligne de commande, il suit ce standard en ce qui concerne les
fichiers de démarrage. Dans ce cas, la variable
<FONT SIZE="-1"><B>ENV</B>

</FONT>
est développée, et le fichier qui en résulte est exécuté. On n'exécute
pas d'autre fichier
d'initialisation.
<P>

<B>Bash</B>

tente de déterminer s'il est exécuté par le démon lançant les shells
distants (généralement appelé <I>rshd</I> ).
Si
<B>bash</B>

se rend compte qu'il est exécuté par <I>rshd</I>, il lit et exécute les
commandes de <I>~/.bashrc</I> si ce fichier existe et est lisible.
Il n'a pas ce comportement lorsqu'il est invoqué sous le nom <B>sh</B>.
L'option
<B>--norc</B>

peut être utilisé pour interdire ce comportement, et l'option
<B>--rcfile</B>

permet de forcer l'utilisation d'un autre fichier, mais <I>rshd</I> 
n'utilise généralement pas ces options et ne permet pas
non plus leur utilisation.
<P>

Si le shell est lancé avec un identifiant effectif d'utilisateur (ou de groupe)
différent de l'identifiant réel, et si l'option <B>-p</B> n'est pas utilisée,
aucun fichier d'initialisation n'est lu, les fonctions du shell ne sont pas
importées depuis l'environnement, la variable <B>SHELLOPTS</B> est ignorée
si elle apparaît dans l'environnement, et l'identifiant effectif de
l'utilisateur (du groupe) est remplacé par l'ID réel. Si l'option <B>-p</B> 
est fournie, le démarrage est le même mais l'ID effectif n'est pas modifié.
<A NAME="lbAI">&nbsp;</A>
<H2>DÉFINITIONS</H2>

<P>

Les définitions suivantes sont utilisées tout au long de ce
document.

<DL COMPACT>
<DT><B>blanc</B>

<DD>
Un espace ou une tabulation.
<DT><B>mot</B>

<DD>
une séquence de caractères considérée comme une unité élémentaire par le shell.
On parle également de
<B>token</B> (jeton).

<DT><B>nom</B>

<DD>
un
<I>mot</I>

ne contenant que des caractères alphanumériques ou le soulignement (underscore),
commençant par une lettre ou un soulignement. On s'y réfère également
sous le terme
<B>identificateur</B>.

<DT><B>méta-caractère</B>

<DD>
Un caractère qui, non protégé, sépare les mots. Un de ceux-ci :
<BR>

<DL COMPACT><DT><DD>
<P>


<B>|  &amp; ; ( ) &lt; &gt; espace tabulation</B>
</DL>

</DL>
<P>

<DL COMPACT>
<DT><B>opérateur de contrôle</B>

<DD>
Un <I>jeton</I> ayant une fonction de contrôle. L'un des symboles
suivants :
<DL COMPACT><DT><DD>
<P>


<B>|| &amp; &amp;&amp; ; ;; ( ) | &lt;retour-chariot&gt;</B>
</DL>


</DL>
<A NAME="lbAJ">&nbsp;</A>
<H2>MOTS RÉSERVÉS</H2>

Les <I>mots réservés</I> ont une signification spéciale pour le shell.
Les mots suivants sont réservés et interprétés par le shell lorsqu'ils
ne sont pas protégés, et s'il s'agit soit du premier
mot d'une commande simple, soit du troisième mot d'une commande
<B>case</B>

ou
<B>for</B>

(voir le paragraphe 
<FONT SIZE="-1"><B>GRAMMAIRE DU SHELL</B>

</FONT>
ci-dessous).

<P>

<B>! case  do done elif else esac fi for function if in select then until while { } time [[  ]]
</B>




<A NAME="lbAK">&nbsp;</A>
<H2>GRAMMAIRE DU SHELL</H2>

<A NAME="lbAL">&nbsp;</A>
<H3>Commandes simples</H3>

<P>

Une <I>commande simple</I> est une séquence d'affectations de variables
facultative, suivie de mots séparés par des <I>blancs</I> et des redirections,
et terminée par un <I>opérateur de contrôle</I>.
Le premier mot indique la commande à exécuter. Les mots suivants sont
transmis en argument à cette commande.
<P>

La valeur de retour d'une <I>commande simple</I> est son code de sortie, ou
128+<I>n</I> si la commande a été interrompue par le signal
<I>n</I>.

<A NAME="lbAM">&nbsp;</A>
<H3>Pipelines</H3>

<P>

Un <I>pipeline</I> est une séquence d'une ou plusieurs commandes séparées par
le caractère
<B>|</B>.

Le format d'un pipeline est :
<DL COMPACT><DT><DD>
<P>

[<B>time</B> [<B>-p</B>]] [ ! ] <I>commande_1</I> [ <B>|</B> <I>commande_2</I> ... ]
</DL>

<P>

La sortie standard de la
<I>commande_1</I>

est connectée à l'entrée standard de la
<I>commande_2</I>.

Cette connexion est établie avant toute redirection indiquée dans
une commande elle-même (voir le paragraphe
<FONT SIZE="-1"><B>REDIRECTION</B>

</FONT>
plus bas).
<P>

Si le mot réservé
<B>!</B>

précède un pipeline, la valeur de sortie de celui-ci sera la NÉGATION
logique de la valeur de retour de la dernière commande. Sinon, le
code de retour d'un pipeline sera celui de la
dernière commande.
L'interpréteur attend la fin de toutes les commandes du pipeline
avant de renvoyer une valeur.
<P>

Si le mot réservé
<B>time</B>

précède le pipeline, les temps passés par le programme en mode utilisateur et
système sont indiqués quand le pipeline se
termine.
L'option <B>-p</B> change le format de sortie pour celui spécifié par POSIX.
La variable
<FONT SIZE="-1"><B>TIMEFORMAT</B>

</FONT>
peut être affectée avec une chaîne de format indiquant comment les informations
horaires doivent être affichées; consultez la descriptions de
<FONT SIZE="-1"><B>TIMEFORMAT</B>

</FONT>
dans
<B>Variables</B>du<B>Shell</B>

plus bas.
<P>

Chaque commande du pipeline est exécutée comme un processus indépendant
(c'est à dire dans un sous-shell).
<A NAME="lbAN">&nbsp;</A>
<H3>Listes</H3>

<P>

Une <I>liste</I> est une séquence d'un ou plusieurs pipelines séparés par
l'un des opérateurs 
<B>;</B>,

<B>&amp;</B>,

<B>&amp;&amp;</B>,

ou
<B>||</B>,

et terminée éventuellement par
<B>;</B>,

<B>&amp;</B>,

ou
<B>&lt;retour-chariot&gt;</B>.

<P>

Dans cette liste d'opérateurs,
<B>&amp;&amp;</B>

et
<B>||</B>

ont une précédence identique, suivis par
<B>;</B>

et
<B>&amp;,</B>

qui ont également une précédence identique.
<P>

Si une commande se termine par l'opérateur de contrôle
<B>&amp;</B>,

l'interpréteur l'exécute en <I>arrière-plan</I>, dans un sous-shell.
L'interpréteur n'attend pas que la commande se termine et retourne
un code 0. Les commandes séparées par un
<B>;</B>

sont exécutées successivement, l'interpréteur attend que chaque
commande se termine avant de lancer la suivante. Le code de retour
est celui de la dernière commande exécutée.
<P>

Les opérateurs de contrôle
<B>&amp;&amp;</B>

et
<B>||</B>

indiquent respectivement une liste liée par un ET, et une liste
liée par un OU. Une liste ET a la forme
<DL COMPACT><DT><DD>
<P>

<I>commande_1</I> <B>&amp;&amp;</B> <I>commande_2</I>
</DL>

<P>

<I>commande_2</I>

est exécutée si, et seulement si,
<I>commande_1</I>

renvoie un code de retour nul.
<P>

Une liste OU a la forme
<DL COMPACT><DT><DD>
<P>

<I>commande_1</I> <B>||</B> <I>commande_2</I>
<P>

</DL>

<P>

<I>commande_2</I>

est exécutée si, et seulement si
<I>commande_1</I>

renvoie un code de retour non-nul.  La valeur de
retour des listes ET et OU est celle de la dernière
commande exécutée dans la liste.
<A NAME="lbAO">&nbsp;</A>
<H3>Commandes composées</H3>

<P>

Une <I>commande composée</I> est l'une des constructions suivantes :
<DL COMPACT>
<DT>(<I>liste</I>)<DD>
<I>liste</I> est exécutée dans un sous-shell. Les affectations de
variables, et les commandes internes qui affectent l'environnement
de l'interpréteur n'ont pas d'effet une fois que la commande se
termine. Le code de retour est celui de la <I>liste</I>.
<DT>{ <I>liste</I>; }<DD>
<I>liste</I> est simplement exécutée avec l'environnement du shell en cours.
<I>liste</I> doit se terminer par un caractère fin-de-ligne ou un point-virgule.
Cette construction est connue sous le nom de <I>commandes groupées</I>.
Le code de retour est celui de la
<I>liste</I>.
<DT>
<DD>
L'<I>expression</I> est évaluée selon les règles décrites
plus bas au paragraphe 
<FONT SIZE="-1"><B>ÉVALUATION</B>ARITHMÉTIQUE<B>.</B>

</FONT>
Si la valeur arithmétique de l'expression est non-nulle, le code renvoyé est
zéro ; sinon 1 est renvoyé. Cela est strictement identique à
<B>let &quot;</B><I>expression</I>&quot;.
<DT><B>[[</B> <I>expression</I> <B>]]</B><DD>
Renvoie 1 ou 0 selon la valeur de la condition
<I>expression</I>.
les expressions sont composées d'éléments primaires décrits dans
<FONT SIZE="-1"><B>EXPRESSIONS</B>CONDITIONNELLES<B>.</B>

</FONT>
Le coupage des mots et l'expansion des chemins ne sont pas réalisés sur les
portions entre <B>[[</B> et <B>]]</B>; l'expansion des tildes, des paramètres,
des variable, des expressions arithmétiques, la substitution des commandes
et des processus, ainsi que la disparition des apostrophes sont réalisés.

<P>

Quand les opérateurs <B>==</B> et <B>!=</B> sont utilisés, la chaîne placée à
droite de l'opérateur est considérée comme étant un motif et est recherchée
selon les règles décrites dans <B>Motifs génériques</B>.
La valeur renvoyée est 0 si les chaînes correspondent (ou respectivement
ne correspondent pas), et 1 sinon.
Toute partie du motif peut être protégée avec des apostrophes pour forcer
sa comparaison en tant que chaîne (sans développement).

<P>

Les expressions peuvent être combinées en utilisant les opérateurs suivants,
par ordre décroissant de priorité :

<P>

<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>( </B><I>expression</I> )

<DD>
Retourne la valeur de l'<I>expression</I>.
Cela peut être utilisé pour outrepasser la priorité normale des opérateurs.
<DT><B>! </B><I>expression</I>

<DD>
Vraie si
<I>expression</I>

est vraie.
<DT><I>expression1</I> <B>&amp;&amp;</B> <I>expression2</I><DD>
Vraie si
<I>expression1</I>

et
<I>expression2</I>

sont toutes les deux vraies.
<DT>
<DD>
<I>expression1</I> <B>||</B> <I>expression2</I>
Vraie si
<I>expression1</I>

ou
<I>expression2</I>

est vraie.

</DL>
</DL>

</DL>
<P>

Les opérateurs <B>&amp;&amp;</B> et

<B>||</B>
n'exécutent pas <I>expression2</I> si la valeur de
<I>expression1</I> suffit à déterminer le code de retour de
l'expression conditionnelle entière.
<DL COMPACT>
<DT><B>for</B> <I>nom</I> [ <B>in</B> <I>mot</I> ]  ; <B>do</B> <I>liste</I> ; <B>done</B><DD>
La liste de mots à la suite de <B>in</B> est développée, créant une liste
d'éléments.  La variable <I>nom</I> prend successivement la valeur de chacun des
éléments, et <I>liste</I> est exécutée à chaque fois. Si <B>in</B> <I>mot</I>
est omis, la commande <B>for</B> exécute la <I>liste</I> une fois pour chacun
des paramètres positionnels ayant une valeur (voir le paragraphe
<FONT SIZE="-1"><B>PARAMÈTRES</B>

</FONT>
plus bas).
Le code de retour est celui de la dernière commande exécutée. Si le
développement de ce qui suit <B>in</B> est une liste vide, aucune commande n'est
exécutée et 0 est renvoyé.
<DT><B>select</B> <I>nom</I> [ <B>in</B> <I>mot</I> ] ; <B>do</B> <I>liste</I> ; <B>done</B><DD>
La liste de mots à la suite de <B>in</B> est développée, créant une liste
d'éléments.  L'ensemble des mots développés est imprimé sur la sortie d'erreur
standard, chacun précédé par un nombre. Si <B>in</B> <I>mot</I> est omis, les
paramètres positionnels sont imprimés (voir le paragraphe
<FONT SIZE="-1"><B>PARAMÈTRES</B>

</FONT>
plus bas). Le symbole d'accueil
<B>PS3</B>

est affiché, et une ligne est lue depuis l'entrée standard.
Si la ligne est constituée d'un nombre correspondant à l'un
des mots affichés, la variable
<I>nom</I>

est remplie avec ce mot. Si la ligne est vide, les mots et le symbole d'accueil
sont affichés à nouveau. Si une fin de fichier (EOF) est lue, la commande se
termine. Pour toutes les autres valeurs, la variable
<I>nom</I>

est vidée. La ligne lue est stockée dans la variable
<B>REPLY</B>.

La
<I>liste</I>

est exécutée après chaque sélection, jusqu'à ce qu'une commande
<B>break</B>

ou
<B>return</B>

soit atteinte.
Le code de retour de
<B>select</B>

est celui de la dernière commande exécutée dans la
<I>liste</I>,

ou zéro si aucune commande n'est exécutée.
<DT><B>case</B> <I>mot</I> <B>in</B> [ <I>motif</I> [ <B>|</B> <I>motif</I> ] 
<DD>
Une commande <B>case</B> commence d'abord par développer le <I>mot</I>,
puis essaye de le mettre en correspondance successivement avec chacun
des <I>motifs</I> en utilisant les mêmes règles que pour les noms de fichiers
(voir le paragraphe
<B>Développement des noms de fichiers</B>

plus bas).  Quand une correspondance est trouvée, la <I>liste</I> associée est
exécutée. Dès qu'un motif correct a été trouvé, il n'y a plus d'autre essais.
Le code retour est zéro si aucun motif ne correspond, sinon il s'agit du
code de la dernière commande exécutée dans la <I>liste</I>.
<DT><B>if</B> <I>liste</I> ; <B>then</B> <I>liste</I> ; [ <B>elif</B> <I>liste</I> ; <B>then</B> <I>liste</I> ; ] ... [ <B>else</B> <I>liste</I> ; ] <B>fi</B><DD>
La
<I>liste</I> du

<B>if </B>

est exécutée. Si son code de retour est nul, la <I>liste</I> du
<B>then</B> est exécutée. Sinon, chacune des <I>listes</I> des
<B>elif</B> est exécutée successivement, et si un code de retour
est nul, la <I>liste</I> du <B>then</B> associé est exécutée, et la
commande se termine.  En dernier ressort, la <I>liste</I> du <B>else</B> est
exécutée. Le code de retour est celui de la dernière commande exécutée,
ou zéro si aucune condition n'a été vérifiée.
<DT>
<DD>
<B>while</B> <I>liste</I> ; <B>do</B> <I>liste</I> ; <B>done</B>
<DT><B>until</B> <I>liste</I> ; <B>do</B> <I>liste</I> ; <B>done</B><DD>

La commande <B>while</B> répète la <I>liste</I> du <B>do</B> tant que la dernière
commande de la <I>liste</I> du <B>while</B> renvoie un code de retour nul.
La commande <B>until</B> agit de même manière, sauf que le test est négatif,
et
la <I>liste</I> du 
<B>do</B> 
est exécutée tant que la <I>liste</I> 
du <B>until</B>
renvoie un code 
non-nul.
Le code de retour des commandes <B>while</B> et <B>until</B>
est celui de la dernière commande exécutée dans la 
liste <B>do</B>,
ou zéro si aucune commande n'a été exécutée.
<DT>[ <B>function</B> ] <I>nom</I> () { <I>liste</I>; }<DD>
Ceci définit une fonction possédant le <I>nom</I> mentionné.
Le corps de cette fonction est la 
<I>liste</I>
de commandes entre { et }. Cette liste est exécutée
dès que le <I>nom</I> de la fonction est invoqué en tant que commande simple.
Le code de retour est celui de la dernière commande exécutée
dans le corps de la fonction. (voir le paragraphe
<FONT SIZE="-1"><B>FONCTIONS</B>

</FONT>
plus bas)
</DL>
<A NAME="lbAP">&nbsp;</A>
<H2>COMMENTAIRES</H2>

Dans un shell non-interactif, ou dans un shell interactif avec l'option
<B>-o interactive-comments</B>

activée par la commande interne
<B>shopt</B>

(voir 
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas), un mot commençant par
<B>#</B>

permettra d'ignorer tous les caractères restants sur la ligne.
Un shell interactif sans l'option
<B>interactive-comments</B>

n'autorise pas les commentaires. L'option
<B>interactive_comments</B>

est activée par défaut dans les shells interactifs.
<A NAME="lbAQ">&nbsp;</A>
<H2>PROTECTION</H2>

Les <I>protections</I> (quoting) permettent de forcer l'interpréteur à
ignorer la signification spéciale de certains caractères ou mots.
Les protections peuvent être utilisées pour empêcher le traitement
des caractères spéciaux, éviter la reconnaissance des mots-réservés
ou empêcher le développement des paramètres.
<P>

Tous les <I>méta-caractères</I> mentionnés dans le paragraphe
<FONT SIZE="-1"><B>DÉFINITIONS</B>

</FONT>
plus haut ont des significations spéciales pour le shell, et
doivent être protégés pour garder leur propre valeur.
Il y a trois mécanismes de protection : le caractère d'échappement, les
apostrophes (quote) et les guillemets (double-quote).
<P>

Un caractère backslash (<B>\</B>), quand il n'est pas protégé, représente le
<I>caractère d'échappement</I>.

Il préserve la valeur littérale du caractère qui le suit, à l'exception
du &lt;retour-chariot&gt;.  Si une séquence <B>\</B>&lt;retour-chariot&gt; apparaît,
et si le backslash n'est pas protégé, l'ensemble <B>\</B>&lt;retour-chariot&gt;
est considéré comme une continuation de ligne 
(autrement dit, il est ignoré).
<P>

Encadrer des caractères entre des apostrophes simples préserve la valeur
littérale de chacun des caractères. Une apostrophe ne peut pas être
placée entre deux apostrophes, même si elle est précédée d'un backslash.
<P>

Encadrer des caractères entre des guillemets préserve la valeur
littérale de chacun des caractères sauf 
<B>$</B>,

<B>`</B>,

et
<B>\</B>.

Les caractères
<B>$</B>

et
<B>`</B>

conservent leurs significations spéciales, même entre guillemets. Le backslash
ne conserve sa signification que lorsqu'il est suivi 
par
<B>$</B>,

<B>`</B>,

<B>&quot;</B>,
<B>\</B>,

ou
<B>&lt;fin-de-ligne&gt;</B>.

Un guillemet peut être protégé entre deux guillemets, à condition de le
faire précéder par un backslash.
<P>

Les caractères spéciaux
<B>*</B>

et
<B>@</B>

ont des significations spéciales lorsqu'ils se trouvent entre guillemets
(voir le paragraphe
<FONT SIZE="-1"><B>PARAMÈTRES</B>

</FONT>
ci-dessous).
<P>

Les mots de la forme <B>$</B>'<I>chaîne</I>' sont traités différemment.
Le mot est développé en <I>chaîne</I> avec les séquences d'échappement
remplacées
par les séquences standards du C ANSI:
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>\a</B>

<DD>
alerte (cloche alias bip)
<DT><B>\b</B>

<DD>
effacement arrière
<DT><B>\e</B>

<DD>
un caractère escape
<DT><B>\f</B>

<DD>
fin de page
<DT><B>\n</B>

<DD>
fin de ligne
<DT><B>\r</B>

<DD>
retour chariot
<DT><B>\t</B>

<DD>
tabulation horizontale
<DT><B>\v</B>

<DD>
tabulation verticale
<DT><B>\\</B>

<DD>
anti-slash (backslash)
<DT><B>\</B><I>nnn</I>

<DD>
le caractère dont le code ASCII en octal est <I>nnn</I>
(un à trois chiffres)
<DT><B>\x</B><I>nnn</I>

<DD>
le caractère dont le code ASCII en hexadécimal est <I>nnn</I>
(un à trois chiffres)

</DL>
</DL>

<P>

Le résultat après traduction est protégé par des apostrophes comme si le
symbole dollar n'avait pas été présent.
<P>

Une chaîne entre guillemets précédée d'un symbole dollar (<B>$</B>) 
sera traduite selon la localisation en vigueur.
Si la locale courante est <B>C</B> ou <B>POSIX</B>,
le symbole dollar est ignoré.
Si la chaîne a subi une traduction ou des remplacements, le résultat
est protégé par des guillemets.
<A NAME="lbAR">&nbsp;</A>
<H2>PARAMÈTRES</H2>

Un
<I>paramètre</I>

est une entité permettant de stocker des valeurs, comme les variables dans
les langages de programmation courants. Il peut se présenter sous forme d'un
<I>nom</I>,

d'un nombre, ou d'un des caractères spéciaux décrits plus bas, dans
<B>Paramètres Spéciaux</B>.

Au niveau du shell, une
<I>variable</I>

est un paramètre muni d'un
<I>nom</I>.

<P>

Un paramètre existe dès qu'on lui attribue une valeur. Une chaîne vide
est une valeur valide. Une fois qu'une variable existe, elle ne peut
être détruite qu'en utilisant la commande interne
<B>unset</B>

(voir
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas).
<P>

Une
<I>variable</I>

peut recevoir une valeur par une affectation de la forme
<DL COMPACT><DT><DD>
<P>

<I>nom</I>=[<I>valeur</I>]
</DL>

<P>

Si aucune
<I>valeur</I>

n'est indiquée, la variable reçoit une chaîne vide. Toute
<I>valeur</I>

est soumise aux principes de développement du tilde, des paramètres
et des variables, de la substitution de commandes, de l'évaluation
arithmétique, et de la suppression des protections (voir
<FONT SIZE="-1"><B>EXPANSION</B>

</FONT>
plus bas). Si une variable a son attribut
<B>-i</B>

activé (voir
<B>declare</B>

plus bas, dans le paragraphe
<FONT SIZE="-1"><B>COMMANDES</B>INTERNES<B>DU</B>SHELL<B>)</B>

</FONT>
alors la
<I>valeur</I>

est soumise à l'évaluation arithmétique, même si la syntaxe $((...))
n'apparaît pas (voir
<B>ÉVALUATION ARITHMÉTIQUE</B>

plus bas).
Les mots ne sont pas tronqués, sauf avec la séquence
<B>&quot;$@&quot;</B> comme cela est expliqué dans le paragraphe
<B>Paramètres Spéciaux</B>

ci-dessous. Le développement des noms de fichiers n'est pas effectué.
<A NAME="lbAS">&nbsp;</A>
<H3>Paramètres Positionnels</H3>

<P>

Un 
<I>paramètre positionnel</I>

est un paramètre indiqué par un ou plusieurs chiffres (à l'exception
du chiffre 0 seul). Les paramètres positionnels sont remplis avec
les arguments du shell lors de son invocation. Ils peuvent être
modifiés avec la commande interne
<B>set</B>.

On ne peut pas utiliser d'assignation pour modifier le contenu
d'un paramètre positionnel.  Les paramètres positionnels sont temporairement
modifiés lors de l'exécution d'une fonction du shell (voir le paragraphe
<FONT SIZE="-1"><B>FONCTIONS</B>

</FONT>
plus bas).
<P>

Un paramètre positionnel constitué de plusieurs chiffres
doit être encadré par des accolades lors de son développement (voir 
<FONT SIZE="-1"><B>EXPANSION</B>

</FONT>
plus bas).
<A NAME="lbAT">&nbsp;</A>
<H3>Paramètres Spéciaux</H3>

<P>

Il existe plusieurs paramètres ayant un comportement particulier. Ces
paramètres peuvent uniquement être consultés, on ne peut pas les modifier.

<DL COMPACT>
<DT><B>*</B>

<DD>
Se développe en l'ensemble des paramètres positionnels, commençant à 1. Quand 
le développement se produit entre des guillemets, <B>*</B> se transforme en un
seul mot constitué de la valeur de tous les paramètres positionnels séparées
par le premier caractère de la variable spéciale
<FONT SIZE="-1"><B>IFS</B>.

</FONT>
Ceci signifie que &quot;<B>$*</B>&quot;  est équivalent à
&quot;<B>$1</B><I>c</I><B>$2</B><I>c</I><B>...</B>&quot;, dans laquelle
<I>c</I>

est le premier caractère de la valeur de la variable
<FONT SIZE="-1"><B>IFS</B>.

</FONT>
Si
<FONT SIZE="-1"><B>IFS</B>

</FONT>
est inexistante, les paramètres sont séparés par des espaces.
Si
<FONT SIZE="-1"><B>IFS</B>

</FONT>
est nulle, les paramètres sont juxtaposés sans séparation.
<DT><B>@</B>

<DD>
Se développe en l'ensemble des paramètres positionnels, commençant à 1. Quand
le développement a lieu entre guillemets, chaque paramètre se transforme en
un mot distinct. Ceci signifie que &quot;<B>$@</B>&quot; est équivalent à
&quot;<B>$1</B>&quot; &quot;<B>$2</B>&quot; ...
Quand il n'y a pas de paramètres positionnels, &quot;<B>$@</B>&quot; et
<B>$@</B>

sont simplement éliminés.
<DT><B>#</B>

<DD>
Correspond au nombre de paramètres positionnels, en base décimale.
<DT><B>?</B>

<DD>
Fournit le code de retour du dernier pipeline exécuté à l'avant-plan.
<DT><B>-</B>

<DD>
Est remplacé par la liste des options du shell indiquées durant l'invocation,
configurées avec la commande interne
<B>set</B>

ou positionnées par le shell lui-même
(comme avec l'option
<B>-i</B>

).
<DT><B>$</B>

<DD>
Se transforme en PID du shell. Dans un sous-shell (), il se
transforme en PID du shell, et non pas du 
sous-shell.
<DT><B>!</B>

<DD>
Se transforme en PID de la commande (asynchrone) exécutée en arrière-plan
le plus récemment.
<DT><B>0</B>

<DD>
Se développe pour donner le nom du shell ou du script. Ce paramètre est
rempli lors de l'initialisation de l'interpréteur. Si
<B>bash</B>

est invoqué avec un fichier de commandes,
<B>$0</B>

correspond au nom de ce fichier. Si
<B>bash</B>

est lancé avec l'option
<B>-c</B>,

alors
<B>$0</B>

contient le premier argument, s'il y en a un, après la chaîne de commandes
à exécuter.
Sinon, ce paramètre contient le chemin d'accès utilisé pour invoquer
<B>bash</B>,

comme il l'a reçu en argument zéro.
<DT><B>_</B>

<DD>
Au lancement du shell, contient le chemin absolu du shell ou du script
en cours d'exécution.
Devient le dernier argument de la commande précédente, après développement.
Correspond aussi au chemin d'accès complet de chaque commande exécutée,
et se retrouve dans l'environnement exporté à cette commande.
Lors de la vérification de l'arrivée de courrier, contient le nom
du fichier de courrier en cours de vérification
[Ndt: généralement <I>/var/mail/nom_de_l_utilisateur</I>].

</DL>
<A NAME="lbAU">&nbsp;</A>
<H3>Variables du Shell</H3>

<P>

Les variables suivantes sont remplies par l'interpréteur de commandes :
<P>


<DL COMPACT>
<DT><B>PPID</B>

<DD>
L'ID du processus parent du shell. Cette variables est protégée en écriture.
<DT><B>PWD</B>

<DD>
Le répertoire de travail en cours, tel qu'il est configuré par
la commande
<B>cd</B>.

<DT><B>OLDPWD</B>

<DD>
Le répertoire de travail précédent,
configuré par la commande
<B>cd</B>.

<DT><B>REPLY</B>

<DD>
Contient la ligne d'entrée lue par la commande interne
<B>read</B>

lorsqu'elle n'a pas d'argument.
<DT><B>UID</B>

<DD>
Contient l'ID de l'utilisateur, initialisé au démarrage
du shell. C'est une variable en lecture seulement
<DT><B>EUID</B>

<DD>
Contient l'UID effectif de l'utilisateur, initialisé au démarrage
du shell. Cette variable est en lecture seule.
<DT><B>GROUPS</B>

<DD>
Variable de type tableau contenant la liste des groupes dont l'utilisateur
est membre. Cette variables est protégée en écriture.
<DT><B>BASH</B>

<DD>
Se développe en chemin d'accès complet à l'instance courrante de
<B>bash</B>.

<DT><B>BASH_VERSION</B>

<DD>
Correspond au numéro de version de cette instance de
<B>bash</B>.

<DT><B>BASH_VERSINFO</B>

<DD>
Une variable tableau protégée en écriture dont les membres représentent la
version de cette instance de
<B>bash</B>.

Cette valeur est renseignée de la manière suivante:
<P>
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>BASH_VERSINFO[</B>0]

<DD>
Le numéro majeur de la version (<I>release</I>).
<DT><B>BASH_VERSINFO[</B>1]

<DD>
Le numéro mineur de la version (<I>version</I>).
<DT><B>BASH_VERSINFO[</B>2]

<DD>
Le niveau de patch.
<DT><B>BASH_VERSINFO[</B>3]

<DD>
Le numéro de compilation.
<DT><B>BASH_VERSINFO[</B>4]

<DD>
Le statut de cette version (e.g., <I>beta1</I>).
<DT><B>BASH_VERSINFO[</B>5]

<DD>
La valeur de <B>MACHTYPE</B>.

</DL>
</DL>

<DT><B>SHLVL</B>

<DD>
(NDT : Lire SH LVL - Shell Level - Niveau d'interpréteur)
Incrémenté de 1 à chaque invocation d'une instance de
<B>bash</B>.

<DT><B>RANDOM</B>

<DD>
A chaque fois que ce paramètre est référencé, un entier aléatoire entre 0 et
32767 est engendré.
Cette séquence de nombres aléatoires peut être initialisée
en assignant une valeur à
<FONT SIZE="-1"><B>RANDOM</B>.

</FONT>
Si
<FONT SIZE="-1"><B>RANDOM</B>

</FONT>
est détruit (commande <B>unset</B>), il perd son comportement spécial,
même s'il est recréé plus tard.
<DT><B>SECONDS</B>

<DD>
A chaque fois que ce paramètre est lu, le nombre de secondes écoulées depuis
le lancement de l'interpréteur est renvoyé. Si une valeur est affectée à
<FONT SIZE="-1"><B>SECONDS</B>,

</FONT>
il renverra lors des lectures ultérieures
le nombre de secondes écoulées
depuis l'affectation,
augmenté de la valeur fournie.
Si
<FONT SIZE="-1"><B>SECONDS</B>

</FONT>
est détruit (commande <B>unset</B>), il perd son comportement spécial,
même s'il est recréé plus tard.
<DT><B>LINENO</B>

<DD>
Chaque fois que ce paramètre est référencé, le shell le remplace
par un nombre décimal représentant le numéro de la ligne actuelle
(commençant à 1), au sein du script ou de la fonction.
Hors d'un script ou d'une fonction, la valeur
n'a pas nécessairement de sens.
Si
<FONT SIZE="-1"><B>LINENO</B>

</FONT>
est détruit (commande <B>unset</B>), il perd son comportement spécial,
même s'il est recréé plus tard.
<DT><B>HISTCMD</B>

<DD>
Le numéro d'historique, ou le rang dans la liste d'historique, de
la commande en cours.
Si
<FONT SIZE="-1"><B>HISTCMD</B>

</FONT>
est détruit (commande <B>unset</B>), il perd son comportement spécial,
même s'il est recréé plus tard.
<DT><B>DIRSTACK</B>

<DD>
Une variable de type tableau (voir
<B>Tableaux</B>

plus bas) représentant le contenu courant de la pile de répertoires.
Les répertoires apparaissent dans la pile dans l'ordre dans lequel
la commande interne
<B>dirs</B>

les affiche.  Il est possible de modifier directement cette variables mais
les commandes internes
<B>pushd</B>

et
<B>popd</B>

doivent être utilisées pour ajouter et enlever des répertoires.
Modifier cette variable ne modifiera pas le répertoire courant.
Si
<FONT SIZE="-1"><B>DIRSTACK</B>

</FONT>
est détruite, elle perd ses propriétés spéciales, même si elle est
recréée.
<DT><B>PIPESTATUS</B>

<DD>
Une variable de type tableau (voir
<B>Tableaux</B>

plus bas) contenant une liste des codes de retour des derniers processus
exécutés en avant-plan
(éventuellement une seule commande).
<DT><B>OPTARG</B>

<DD>
La valeur du dernier argument d'option traité par la commande interne
<B>getopts</B>

(voir le paragraphe
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas).
<DT><B>OPTIND</B>

<DD>
Le rang du prochain argument à traiter avec la commande
<B>getopts</B>

(voir le paragraphe
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas).
<DT><B>HOSTNAME</B>

<DD>
Automatiquement affectée avec le nom de l'ordinateur.
<DT><B>HOSTTYPE</B>

<DD>
Automatiquement rempli avec une chaîne qui décrit de manière
unique le type de machine sur laquelle
<B>bash</B>

s'exécute.
La valeur par défaut dépend du système.
<DT><B>OSTYPE</B>

<DD>
Automatiquement rempli avec une chaîne qui décrit le
système d'exploitation sur lequel
<B>bash</B>

s'exécute.
La valeur par défaut dépend du système.
<DT><B>MACHTYPE</B>

<DD>
Automatiquement affectée avec une chaîne décrivant le type du système
sur lequel
<B>bash</B>

s'exécute, dans le format standard de GNU <I>processeur-compagnie-système</I>.
La valeur par défaut dépend du système.
<DT><B>SHELLOPTS</B>

<DD>
Liste des options activées du shell, séparées par des virgules.
Chaque mot de la liste est un argument valide pour l'option
<B>-o</B>

de la commande interne
<B>set</B>

(voir
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>).</FONT>
Les options apparaissant dans
<FONT SIZE="-1"><B>SHELLOPTS</B>

</FONT>
sont celle indiquées comme
<I>actives</I>

par <B>set -o</B>.
Si cette variable est dans l'environnement au lancement de
<B>bash</B>,

chaque option de la liste est activée avant de lire les fichiers
d'initialisation.
Cette variable est protégée en écriture.

</DL>
<P>

Les variables suivantes sont utilisées par l'interpréteur. Dans certains cas, 
<B>bash</B>

affecte des valeurs par défaut aux variables, ces cas sont décrits
plus bas.
<P>


<DL COMPACT>
<DT><B>IFS</B>

<DD>
Le Séparateur de Champs Interne 
<I>Internal Field Separator</I>

qui est utilisé pour séparer les mots après les développements,
et pour découper les lignes en mots 
avec la commande interne
<B>read</B>.

La valeur par défaut est
``&lt;espace&gt;&lt;tabulation&gt;&lt;retour-chariot&gt;''.
<DT><B>PATH</B>

<DD>
Le chemin de recherche des commandes à exécuter. Il s'agit d'une liste
de répertoires, séparés par des deux-points (`:') que l'interpréteur
consulte lorsqu'il recherche une commande (voir le paragraphe
<FONT SIZE="-1"><B>EXÉCUTION DES COMMANDES</B>

</FONT>
plus bas). Le chemin par défaut dépend du système, et de la configuration
choisie par la personne installant
<B>bash</B>.

Une configuration fréquente est
``/bin:/usr/bin:/usr/local/bin:.''.
<DT><B>HOME</B>

<DD>
Le répertoire personnel de l'utilisateur. C'est l'argument par défaut
de la commande interne <B>cd</B>.
Cette variable sert également lors du développement du tilde.
<DT><B>CDPATH</B>

<DD>
Le chemin de recherche de la commande interne
<B>cd</B>.

Il s'agit d'une liste de répertoires, séparés par des deux-points (`:')
que l'interpréteur consulte lorsqu'il cherche un sous-répertoire destination
de la commande
<B>cd</B>.

Une configuration possible serait ``.:~:/usr''.
<DT><B>BASH_ENV</B>

<DD>
Si ce paramètre est configuré lorsque <B>bash</B> exécute un script, sa valeur
est considérée comme un nom de fichier, contenant les commandes d'initialisation
de l'interpréteur, comme 
<I>.bashrc</I>.

La valeur de
<FONT SIZE="-1"><B>BASH_ENV</B>

</FONT>
est soumise au remplacement des paramètres, substitution de commandes, et
évaluation arithmétique avant d'être considérée comme nom de fichier.
<FONT SIZE="-1"><B>PATH</B>

</FONT>
n'est pas utilisée pour rechercher le fichier obtenu.
<DT><B>MAIL</B>

<DD>
Si ce paramètre correspond à un nom de fichier, et si la variable
<FONT SIZE="-1"><B>MAILPATH</B>

</FONT>
n'est pas configurée,
<B>bash</B>

informera l'utilisateur si un courrier arrive dans le fichier indiqué.
<DT><B>MAILCHECK</B>

<DD>
Indique une période (en secondes),
par défaut 60, avec laquelle
<B>bash</B>

vérifiera si un nouveau courrier est arrivé. Lorsque le délai est écoulé,
le shell vérifiera la présence d'un courrier avant d'afficher son symbole
d'accueil.  Si cette variable est détruite, le shell cessera la vérification.
<DT><B>MAILPATH</B>

<DD>
Il s'agit d'une liste de fichiers séparés par des deux-points (`:'), dans
lesquels on vérifiera l'arrivée de courrier. Le nom d'un fichier peut être
suivi d'un point d'interrogation, puis d'une chaîne de caractères indiquant
le message à afficher en cas de courrier. Dans cette chaîne, le paramètre
<B>$_</B> correspond au nom du fichier.
Exemple:
<DL COMPACT><DT><DD>
<P>

<B>MAILPATH</B>='/usr/spool/mail/bfox?&quot;Tu as du courrier&quot;:~/shell-mail?&quot;$_ a du courrier&quot;'
<P>

<B>Bash</B>

fournit une valeur par défaut pour cette variable, mais l'emplacement du
fichier boîte à lettres dépend du système (par exemple /usr/spool/mail/<B>$USER</B>).
</DL>

<DT><B>PS1</B>

<DD>
La valeur de ce paramètre est développée puis utilisée comme symbole
d'accueil principal (voir le paragraphe
<FONT SIZE="-1"><B>SYMBOLE D'ACCUEIL</B>

</FONT>
ci-dessous).  La valeur par défaut est ``<B>\s-\v\$ </B>''.
<DT><B>PS2</B>

<DD>
La valeur de ce paramètre est développée comme
<B>PS1</B>

puis utilisée comme symbole d'accueil secondaire. Par défaut il s'agit de
``<B>&gt; </B>''.
<DT><B>PS3</B>

<DD>
La valeur de ce paramètre est utilisée comme symbole pour la commande
<I>select</I>

(voir
<FONT SIZE="-1"><B>GRAMMAIRE DU SHELL</B>

</FONT>
plus haut).
<DT><B>PS4</B>

<DD>
La valeur de ce paramètre est développée comme
<B>PS1 </B>

puis affichée entre chaque commande
lors d'un suivi d'exécution.
Le premier caractère de
<FONT SIZE="-1"><B>PS4</B>

</FONT>
est répété autant de fois que nécessaire pour indiquer le
niveau d'imbrication. La valeur par défaut est ``<B>+ </B>''.
<DT><B>TIMEFORMAT</B>

<DD>
La valeur de ce paramètre est utilisée en tant que chaîne de format pour
afficher le temps consommé dans les pipelines préfixés avec le mot
réservé
<B>time</B>.

Le caractère <B>%</B> introduit une séquence d'échappement qui est développée
avec une valeur de temps ou une autre information.
Les séquences d'échappement et leurs significations sont les suivantes; les
accolades entourent les parties facultatives.
<P>
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>%%</B>

<DD>
Un <B>%</B> seul (non interprété).
<DT><B>%[</B><I>p</I>][l]R

<DD>
Le temps écoulé en secondes.
<DT><B>%[</B><I>p</I>][l]U

<DD>
Le temps processeur écoulé en mode utilisateur en secondes.
<DT><B>%[</B><I>p</I>][l]S

<DD>
Le temps processeur écoulé en mode système en secondes.
<DT><B>%P</B>

<DD>
Le pourcentage de temps processeur utilisé calculé avec (%U + %S) / %R.

</DL>
</DL>

<DT><DD>
La séquence facultative <I>p</I> est un chiffre indiquant la <I>précision</I>,
le nombre de chiffres après la virgule.
Une valeur de 0 provoque l'affichage de nombre entiers.
Trois chiffres au plus peuvent être affichés après la virgule;
tout chiffre supérieur à 3 sera changé en 3.
Si <I>p</I> n'est pas indiqué, 3 est utilisé.
<DT><DD>
La séquence optionnelle <B>l</B> spécifie un format étendu, incluant les
minutes, de la forme <I>MM</I>m<I>SS</I>.<I>FF</I>s.
La valeur de <I>p</I> détermine si la partie décimale est
affichée ou non.
<DT><DD>
Si cette variable n'est pas assignée, <B>bash</B> réagit comme si la valeur
<B>$'\nreal\t%3lR\nuser\t%3lU\nsys	%3lS'</B> avait été affectée.
Si la variable est vide, aucune information n'est affichée.
Un caractère fin-de-ligne est ajouté à la fin de l'affichage.
<DT><B>HISTSIZE</B>

<DD>
Le nombre de commandes à mémoriser dans l'historique (voir le paragraphe
<FONT SIZE="-1"><B>HISTORIQUE</B>

</FONT>
plus bas). La valeur par défaut est 500.
<DT><B>HISTFILE</B>

<DD>
Le nom du fichier d'historique pour la mémorisation des commandes(voir
<FONT SIZE="-1"><B>HISTORIQUE</B>

</FONT>
plus bas). Par défaut, il s'agit de <I>~/.bash_history</I>. Si cette variable est
détruite, l'historique n'est pas enregistré en fin de shell.
<DT><B>HISTFILESIZE</B>

<DD>
Le nombre maximal de lignes contenues dans le fichier historique. Quand
cette variable contient une valeur, le fichier historique est tronqué,
si besoin est, pour ne contenir que ce nombre de lignes. La valeur par
défaut est 500. Ce fichier est tronqué à cette taille après écriture
quand un shell interactif se termine.
<DT><B>OPTERR</B>

<DD>
Si cette variable contient la valeur 1,
<B>bash</B>

affiche les messages d'erreurs déclenchés par la commande interne
<B>getopts</B>

(voir le paragraphe
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas).
<FONT SIZE="-1"><B>OPTERR</B>

</FONT>
est initialisé avec la valeur 1 à chaque invocation du shell, ou
au lancement d'un script.
<DT><B>LANG</B>

<DD>
Détermine la localisation pour toutes les catégories non spécifiquement
précisées par une variable commençant par <B>LC_</B>.
<DT><B>LC_ALL</B>

<DD>
Cette variable surcharge <B>LANG</B> et toute autre variable
<B>LC_</B> indiquant la localisation.
<DT><B>LC_COLLATE</B>

<DD>
Cette variable détermine l'ordre des lettres lors du tri des chemins ainsi que
le comportement des expressions des intervalles, des classes d'équivalences,
et de la comparaison de chaînes lors de la recherche de motifs
et le développement des chemins.
<DT><B>LC_CTYPE</B>

<DD>
Cette variable détermine l'interprétation des caractères et le comportement
des classes de caractères [Ndt: ex: [:alpha] ] lors du développement des
chemins et de la recherche de motifs.
<DT><B>LC_MESSAGES</B>

<DD>
Cette variable détermine le langage des messages et celui utilisé pour
traduire les chaînes entre guillemets précédés par un <B>$</B>.
<DT><B>PROMPT_COMMAND</B>

<DD>
Lorsque cette variable contient une valeur, celle-ci est exécutée
en tant que commande, avant l'affichage du symbole d'accueil principal.
<DT><B>IGNOREEOF</B>

<DD>
Cette variable contrôle le comportement du shell lorsqu'il reçoit
un caractère
<FONT SIZE="-1"><B>EOF</B>

</FONT>
(fin de fichier) comme unique entrée. Si elle configurée, la valeur
de cette variable correspond au nombre de caractères
<FONT SIZE="-1"><B>EOF</B>

</FONT>
consécutifs apparaissant en début de ligne que
<B>bash</B>

ignorera avant de se terminer. Si cette variable existe mais que sa valeur
n'est pas numérique, ou si elle n'a pas de valeur, <B>bash</B> accepte par
défaut 10 <I>EOF</I> consécutifs avant de se terminer.  Si elle n'existe pas,
<FONT SIZE="-1"><B>EOF</B>

</FONT>
est considéré comme un terminateur de saisie pour le shell.
<DT><B>TMOUT</B>

<DD>
Si cette variable contient une valeur supérieure a zéro, celle-ci est
considérée comme un délai en secondes, à partir de l'affichage du symbole
d'accueil principal. Lorsque ce délai sera écoulé,
<B>Bash</B>

se terminera si aucune saisie n'a eu lieu.
<DT><B>FCEDIT</B>

<DD>
L'éditeur par défaut utilisé
par la commande interne
<B>fc</B>.

<DT><B>FIGNORE</B>

<DD>
Une liste de suffixes, séparés par des deux-points `:', que <B>bash</B>
ignorera lors de la complétion des noms de fichiers (voir le paragraphe
<FONT SIZE="-1"><B>READLINE</B>

</FONT>
plus bas).
Un nom de fichier dont le suffixe correspond à l'un de ceux mentionnés dans
<FONT SIZE="-1"><B>FIGNORE</B>

</FONT>
est exclus de la liste des fichiers. Par exemple, cette
variable peut prendre la valeur ``.o:~''.
<DT><B>GLOBIGNORE</B>

<DD>
Une liste de motifs séparés par des deux-points, définissant la liste des noms
de fichiers à ignorer lors du développement des chemins.
Si un nom de fichier correspondant à un motif d'expansion, correspond
également à un motif dans
<FONT SIZE="-1"><B>GLOBIGNORE</B>,

</FONT>
il est supprimé de la liste des correspondances.
<DT><B>INPUTRC</B>

<DD>
Le nom du fichier de configuration de
<B>readline</B>

prioritaire sur le fichier par défaut

<I>~/.inputrc</I>

(voir 
<FONT SIZE="-1"><B>READLINE</B>

</FONT>
plus bas).
<DT><B>HISTCONTROL</B>

<DD>
Si cette variable contient la valeur
<I>ignorespace</I>,

les lignes commençant par un caractère d'espacement ne
seront par mémorisées
dans l'historique.
Si elle contient la valeur
<I>ignoredups</I>,

une ligne correspondant exactement à la ligne de commande
précédente ne sera pas dupliquée dans l'historique. La valeur
<I>ignoreboth</I>

permet de combiner ces deux comportements.
Si la variable est détruite (commande <B>unset</B>), ou si elle contient une
valeur différente des trois mentionnées ci-dessus, tous les lignes lues par
l'interpréteur seront mémorisées dans la liste d'historique, sous contrôle
de
<B>HISTIGNORE</B>.

Le fonctionnement de cette variable est surchargé par
<B>HISTIGNORE</B>.

La seconde ligne et les suivantes d'une commande multiligne ne sont pas
testées, et sont ajoutées dans l'historique quelque soit la valeur de
<B>HISTCONTROL</B>.

<DT><B>HISTIGNORE</B>

<DD>
Une liste de motifs séparés par des deux-points déterminant quelles lignes
de commandes seront ajoutées à l'historique. Chaque motif est accroché au
début de la ligne et doit lui correspondre en entier (il n'y a pas d'ajout
de `<B>*</B>' implicite). Chaque motif est comparé à chaque ligne après que les
vérifications de
<B>HISTCONTROL</B>

aient été appliquées.
En plus des motifs génériques normaux du shell, `<B>&amp;</B>' correspond à
la ligne précédente de l'historique. `<B>&amp;</B>' peut être protégé par un
anti-slash. Ce dernier est éliminé avant de tenter une comparaison.
La seconde ligne et les suivantes d'une commande multiligne ne sont pas
testées, et sont ajoutées dans l'historique quelque soit la valeur de
<B>HISTIGNORE</B>.

<DT><B>histchars</B>

<DD>
Cette variable contient deux ou trois caractères contrôlant
le développement de l'historique, et le découpage en jetons (voir
<FONT SIZE="-1"><B>DÉVELOPPEMENT DE L'HISTORIQUE</B>

</FONT>
plus bas). Le premier caractère est le
<I>caractère de développement de l'historique</I>,

c'est à dire celui qui indique le début d'un développement
d'historique (normalement `<B>!</B>').
Le second caractère est celui de
<I>substitution rapide</I>,

utilisé comme raccourci pour relancer la commande précédente,
en modifiant une partie de la chaîne.
Par défaut il s'agit de `<B>^</B>'.
L'éventuel troisième caractère est celui qui indique, lorsqu'on
le trouve en début de mot que le reste de la ligne est un commentaire.
Normalement on utilise le caractère `<B>#</B>'. Ce caractère de commentaire
empêche l'expansion de l'historique pour tous les mots restants sur la ligne.
En revanche, il ne s'agit pas obligatoirement du caractère de commentaire pour
l'interpréteur.
<DT><B>HOSTFILE</B>

<DD>
Contient le nom d'un fichier ayant le même format que

<I>/etc/hosts</I>

qui sera consulté lorsque le shell devra compléter un nom d'hôte. Ce
fichier peut être changé de manière interactive. Lors de la prochaine
tentative pour compléter un nom d'hôte, 
<B>bash</B>

ajoutera le nouveau fichier à sa base de données déjà existantes.
<DT><B>auto_resume</B>

<DD>
Cette variable configure le comportement du shell interactif vis-à-vis de
l'utilisateur et du contrôle de jobs. Si cette variable existe, les commandes
simples constituées d'un seul mot sont considérées comme de possibles relances
de travaux arrêtés. Aucune ambiguïté n'est possible, si plusieurs travaux
arrêtés commencent par la chaîne saisie, <B>bash</B> sélectionne le job manipulé
le plus récemment. Le
<I>nom</I>

du job arrêté correspond, dans ce contexte, à la ligne de commande utilisée
pour le lancer.
Si cette variable contient la valeur
<I>exact</I>,

la chaîne fournie doit correspondre exactement au nom d'un
job arrêté. Si elle contient la valeur
<I>substring</I>,

la chaîne fournie doit correspondre à une sous-chaîne du nom
du job arrêté. La valeur
<I>substring</I>

fournit un comportement analogue au job id
<B>%?</B>

(voir
<FONT SIZE="-1"><B>CONTRÔLE DES JOBS</B>

</FONT>
<BR>&nbsp;plus&nbsp;bas).&nbsp;Si&nbsp;la&nbsp;variable&nbsp;contient&nbsp;n'importe&nbsp;quelle&nbsp;autre&nbsp;valeur,
la chaîne fournie doit correspondre à un préfixe du nom d'un job
arrêté.
C'est analogue au fonctionnement du job id
<B>%</B>.

</DL>
<A NAME="lbAV">&nbsp;</A>
<H3>Tableaux</H3>

<B>Bash</B>

propose des variables tableaux à une dimension. N'importe quelle variable
peut être utilisée comme tableau ; la commande interne
<B>declare</B>

peut servir à déclarer explicitement un tableau. Il n'y a pas de limite maximale
à la taille d'un tableau, ni d'obligation que les membres soient indexés ou
assignés de manière contigûe. Les tableaux sont indexés par des entiers
en commençant à zéro.
<P>

Un tableau est créé automatiquement si une variable est remplie en utilisant
la syntaxe <I>nom</I>[<I>index</I>]=<I>valeur</I>.
l'<I>index</I>

est traîté comme une expression arithmétique, et s'évaluer en un nombre
positif ou nul. Pour déclarer explicitement un tableau, on utilise
<B>declare -a </B><I>nom</I>

(voir
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas).
<B>declare -a </B><I>nom</I>[<I>index</I>]

est aussi accepté bien que l'<I>index</I> soit ignoré. Des attributs peuvent
être spécifié pour une variable tableau en utilisant les commandes internes
<B>declare</B>

et
<B>readonly</B>.

Les attributs s'appliquent à tous les membres du tableau.
<P>

Les tableaux sont remplis en utilisant l'affectation composée de la forme
<I>nom</I>=<B>(</B>valeur_<I>1</I> ... valeur_<I>n</I><B>)</B>, où chaque
<I>valeur</I> est de la forme [<I>index</I>]=<I>chaîne</I>. Seule la
<I>chaîne</I> est obligatoire. Si les crochets et les index optionnels sont
fournis, les affectations ont lieu en conséquence ;
sinon le rang de l'elément rempli est le dernier rang rempli plus un.
Les index commencent à zéro.
Cette syntaxed est aussi acceptée par la commande interne
<B>declare</B>.

Les éléments individuels du tableaux sont remplis en utilisant la syntaxe
<I>nom</I>[<I>index</I>]=<I>valeur</I> présentée plus haut.
<P>

Chaque élément d'un tableau peut référencé en utilisant la notation
${<I>nom</I>[<I>index</I>]}. Les accolades sont indispensables pour éviter
les conflits avec le développement des noms de fichiers. Si
<I>index</I> est <B>@</B> ou <B>*</B>, le développement donne tous
les membres de <I>nom</I>. Ces deux index diffèrent lorsqu'ils sont
employés entre guillemets. Dans ce cas,
${<I>nom</I>[*]} correspond à un seul mot contenant les valeurs
de tous les membres séparés par le premier caractère de la variable
spéciale
<FONT SIZE="-1"><B>IFS</B>,

</FONT>
et ${<I>nom</I>[@]} développe chaque membre de
<I>nom</I> en un mot distinct. Quant il n'y a pas de membre dans le tableau,
${<I>nom</I>[@]} n'a pas de valeur. Le comportement est analogue à celui 
des paramètres spéciaux <B>*</B> et <B>@</B> (voir
<B>Paramètres spéciaux</B>

plus haut).  ${#<I>nom</I>[<I>index</I>]} donne la longueur du membre
${<I>nom</I>[<I>index</I>]}. Si l'<I>index</I> est <B>*</B> ou
<B>@</B>, le développement donne le nombre d'éléments dans le tableau.
Référencer une variable sans index est équivalent à en référencer 
l'élément zéro.
<P>

La commande interne
<B>unset</B>

sert à détruire les tableaux. <B>unset</B> <B>nom</B>[<I>index</I>]
détruit l'élément de rang <I>index</I>.
<B>unset</B> <I>nom</I>, où <I>nom</I> est un tableau, ou
<B>unset</B> <I>nom</I>[<I>index</I>], avec
<I>index</I> valant <B>*</B> ou <B>@</B> supprimer le tableau entier.
<P>

Les commandes internes
<B>declare</B>,

<B>local</B>,

et
<B>readonly</B>

acceptent toutes une option
<B>-a</B>

pour spécifier un tableau. La commande interne
<B>read</B>

accepte une option
<B>-a</B>

pour remplir un tableau avec une liste de mots lus
depuis l'entrée standard. Les commandes internes
<B>set</B>

et
<B>declare</B>

affiche les valeurs des tableaux d'une manière permettant de
les réutiliser pour les affectations.
<A NAME="lbAW">&nbsp;</A>
<H2>EXPANSION</H2>

Les expansions sont appliquées à la ligne de commande après
qu'elle ait été divisée en mots. Il existe sept types de développements :
<I>expansion des accolades</I>,

<I>développement du tilde</I>,

<I>remplacement des paramètres et variables</I>,

<I>substitution de commandes</I>,

<I>évaluation arithmétique</I>,

<I>découpage des mots</I>,

et
<I>développement des noms de fichiers</I>.

<P>

L'ordre est : expansion des accolades, du tilde, des
paramètres, des variables, des commandes, évaluation arithmétique
(selon la méthode gauche-à-droite), découpage des mots et
développement des
noms de fichiers.
<P>

Sur les systèmes qui le supportent, un développement supplémentaire
a lieu :  la <I>substitution de processus</I>.
<P>

Seuls l'expansion des accolades, le découpage des mots, et le développement
des noms de fichiers peuvent modifier le nombre de mots. Les autres
développement transforment un mot unique en un autre mot unique.
La seule exception à cette règle est l'expansion de
&quot;<B>$@</B>&quot; et &quot;<B>${</B><I>nom</I><B>[@]}</B>&quot; comme on l'a vu plus haut
(voir le paragraphe
<FONT SIZE="-1"><B>PARAMÈTRES</B>).

</FONT>
<A NAME="lbAX">&nbsp;</A>
<H3>Expansion des accolades</H3>

<P>

L'<I>expansion des accolades</I>

est un mécanisme permettant la création de chaînes quelconques. Il
est similaire au <I>développement des noms de fichiers</I>, mais les
noms de fichiers créés n'existent pas nécessairement. Les motifs
qui seront développes prennent la forme d'un
<I>préambule </I>

facultatif, suivi d'une série de chaînes séparées par des virgules,
encadrée par des accolades. Un
<I>postambule</I>

peut éventuellement suivre la série de chaînes.
Le préambule est inséré devant chacune des chaînes contenues entre
les accolades, et le postambule est ajouté à la fin de chacune des
chaînes résultantes, le développement se faisant de gauche à droite.
<P>

Plusieurs développements d'accolades peuvent être imbriqués. Les résultats de
chaque développement ne sont pas triées, l'ordre gauche à droite est conservé.
Par exemple a<B>{</B>d,c,b<B>}</B>e se développe en `ade ace abe'.
<P>

L'expansion des accolades est effectuée en premier, et tous les caractères
ayant une signification spéciale pour les autres développement sont conservés
dans le résultat. Il s'agit d'une modification purement littérale.
<B>Bash</B>

n'effectue aucune interprétation syntaxique du texte entre les
accolades.
<P>

Une formule correcte pour le développement doit contenir des accolades
ouvrantes et fermantes non protégées, et au moins une virgule non protégée.
Toute formule incorrecte n'est pas développée et reste inchangée.
Un <B>{</B> ou un <B>,</B> peuvent être protégés par un anti-slash pour éviter
d'être considérés comme partie d'une expression entre accolades.
<P>

Cette construction est généralement utilisée comme raccourci lorsque
le préfixe commun aux différentes chaînes est 
relativement long :
<DL COMPACT><DT><DD>
<P>

mkdir /usr/local/src/bash/{old,new,dist,bugs}
</DL>

ou
<DL COMPACT><DT><DD>
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
</DL>

<P>

Le développement des accolades induit une légère incompatibilité
avec les versions traditionnelles de l'interpréteur Bourne
<B>sh</B>.

<B>sh</B>

n'effectue aucun traitement sur les accolades ouvrantes et fermantes
lorsqu'elles apparaissent dans un mot, et les laisse inchangées.
<B>Bash</B>

supprime les accolades dans les mots, après développement. Par exemple
si l'on fournit à
<B>sh</B>

le mot <I>file{1,2}</I>,
il reste inchangé en sortie. Par contre, il
est transformé en
<I>file1 file2</I>

par
<B>bash</B>.

Si une compatibilité stricte avec
<B>sh</B>

est nécessaire, lancez
<B>bash</B>

avec l'option
<B>+B</B>

ou désactivez le développement des accolades avec l'option
<B>+B</B>

de la commande
<B>set</B>

(voir le paragraphe
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas).
<A NAME="lbAY">&nbsp;</A>
<H3>Développement du Tilde</H3>

<P>

Si un mot commence avec le caractère tilde (`<B>~</B>'), tous les caractères
précédant le premier slash non protégé (voire tous les caractères s'il
n'y a pas de slash), sont considérés comme un <I>préfixe tilde</I>.
Si aucun caractère du préfixe tilde n'est protégé, les caractères suivant
le tilde sont traités comme un
<I>nom de login</I> possible.
Si ce <I>nom de login</I> est une chaîne nulle, le tilde est remplacé par la
valeur du paramètre
<FONT SIZE="-1"><B>HOME</B>.

</FONT>
Si
<FONT SIZE="-1"><B>HOME</B>

</FONT>
n'existe pas, le tilde est remplacé par le répertoire de connexion de
l'utilisateur exécutant le shell.
Si le préfixe tilde est remplacé par le répertoire personnel associé au
nom de login en question.
<P>

Si le préfixe tilde est `+', la valeur du paramètre shell
<FONT SIZE="-1"><B>PWD </B>

</FONT>
le remplace.
Si le préfixe tilde est `-', la valeur du paramètre shell
<FONT SIZE="-1"><B>OLDPWD</B>

</FONT>
lui est substitué.
Si les caractères à la suite du tilde dans le préfixe tilde représentent un
nombre <I>N</I> préfixé éventuellement d'un `+' ou d'un `-'
le préfixe tilde est remplacé par l'élément correspondant de la pile de
répertoires telle qu'il serait affiché par la commande interne
<B>dirs</B>

invoquée avec le préfixe tilde en argument.
Si les caractères à la suite du tilde dans le préfixe tilde représentent un
nombre sans signe, on suppose qu'il s'agit de `+'.
<P>

Si le nom est invalide, ou si le
développement du tilde échoue, le mot est inchangé.
<P>

Chaque affectation de variable est soumis au développement du
tilde s'il suit immédiatement un
<B>:</B>

ou un
<B>=</B>.

On peut donc utiliser des chemins d'accès avec un tilde pour remplir
les variables
<FONT SIZE="-1"><B>PATH</B>,

</FONT>
<FONT SIZE="-1"><B>MAILPATH</B>,

</FONT>
et
<FONT SIZE="-1"><B>CDPATH</B>,

</FONT>
et le shell fournira la valeur correcte.
<A NAME="lbAZ">&nbsp;</A>
<H3>Remplacement des paramètres</H3>

<P>

Le caractère `<B>$</B>' permet d'introduire le remplacement des
paramètres, la substitution de commandes, ou l'expansion arithmétique.
Le nom du paramètre ou du symbole à développer
peut être encadré par
des accolades, afin d'éviter que les caractères suivants ne soient
considérés comme appartenant au nom de la variable.
<P>

Lorsque les accolades sont utilisées, l'accolade finale est le premier
caractère `<B>}</B>' non protégé par un antislash ni inclus dans une chaîne
protégé, ni dans une expresssion arithmétique, une substitution de commande
ou un développement de paramètre.
<P>


<DL COMPACT>
<DT>${<I>paramètre</I>}<DD>
est remplacé par la valeur du <I>paramètre</I>. Les accolades sont
nécessaire quand le
<I>paramètre</I>

est un paramètre positionnel ayant plusieurs chiffres,
ou si le
<I>paramètre</I>

est suivi de caractères n'appartenant
pas à son nom.

</DL>
<P>

Si le premier caractère du <I>paramètre</I> est un point d'exclamation,
un niveau d'indirection de variable est introduit.
<B>Bash</B> utilise la valeur de la variable formée par le reste du
<I>paramètre</I> comme un nom de variable. Cette variable est alors 
développée et la valeur utilisée pour le reste de la substitution plutôt que
la valeur du <I>paramètre</I> lui-même.
On appelle ce mécanisme <I>le développement indirect</I>.
<P>

Dans chacun des exemples suivants, le <I>mot</I> est soumis au
développement du tilde, au remplacement des paramètres, à la
substitution de commandes, et à l'évaluation arithmétique.
<B>Bash</B> vérifie si un paramètre existe, et s'il n'est pas nul.
L'omission du double point ne fournit qu'un test d'existence.
<P>


<DL COMPACT>
<DT>${<I>paramètre</I><B>:-</B><I>mot</I>}<DD>
<B>Utilisation d'une valeur par défaut</B>.  Si le
<I>paramètre</I>

est inexistant ou nul, on substitue le développement du
<B>mot</B>.

Sinon, c'est la valeur du
<I>paramètre</I>

qui est fournie.
<DT>${<I>paramètre</I><B>:=</B><I>mot</I>}<DD>
<B>Attribution d'une valeur par défaut</B>.
Si le
<I>paramètre</I>

est inexistant ou nul, le développement du
<I>mot</I>

lui est
affecté.
La valeur du
<I>paramètre</I>

est alors renvoyée. Les paramètres positionnels, et spéciaux ne peuvent
pas être affectés de cette façon.
<DT>${<I>paramètre</I><B>:?</B><I>mot</I>}<DD>
<B>Affichage d'une erreur si inexistant ou nul</B>.
Si le
<I>paramètre</I>

est inexistant, ou nul, le développement du <I>mot</I> (ou un message approprié
si aucun
<I>mot</I>

n'est fourni) est affiché sur la sortie d'erreur standard, et l'interpréteur
se termine, s'il n'est pas interactif. Autrement, la valeur du <I>paramètre</I>
est utilisée.
<DT>${<I>paramètre</I><B>:+</B><I>mot</I>}<DD>
<B>Utilisation d'une valeur différente</B>.
Si le
<I>paramètre</I>

est nul, ou inexistant, rien n'est substitué. Sinon le développement du
<I>mot</I>

est renvoyé.
<DT>
<DD>
${<I>paramètre</I><B>:</B><I>début</I>}
<DT>${<I>paramètre</I><B>:</B><I>début</I><B>:</B><I>longueur</I>}<DD>

<B>Extraction de sous-chaîne</B>
Se développe pour fournir la sous-chaîne de la <I>longueur</I> indiquée (en
caractères) commençant au <I>début</I>.D <I>offset</I>.
Si la <I>longueur</I> est omise, fournit la sous-chaîne commençant
au caractère de <I>début</I> et s'étendant jusqu'à la fin du <I>paramètre</I>.
La <I>longueur</I> et le <I>début </I> sont des expressions arithmétiques (voir
<FONT SIZE="-1"><B>ÉVALUATION ARITHMÉTIQUE</B>

</FONT>
plus bas).
La <I>longueur</I> doit être positive ou nulle.
Si le <I>début</I> est négatif, sa valeur est considérée
à partir de la fin du contenu du <I>paramètre</I>.
Si le <I>paramètre</I> est <B>@</B>, le résultat correspond aux <I>longueur</I>
paramètres positionnels commençant au <I>début</I>.
Si le <I>paramètre</I> est un nom de tableau indexé par @ ou *,
le résultat est les <I>longueur</I> membres du tableau
commençant à ${<I>paramètre</I>[<I>début</I>]}.
L'indexation des sous-chaînes débute à zéro, sauf pour les paramètres
positionnels qui débute en 1.
<DT>${<B>#</B><I>paramètre</I>}<DD>
Est remplacé par la longueur, en caractères, de la valeur du <I>paramètre</I>.
Si le
<I>paramètre</I>

est
<B>*</B>

ou
<B>@</B>,

la valeur est le nombre de paramètres positionnels.
Si le
<I>paramètre</I>

est un nom de tableau indexé par
<B>*</B>

ou
<B>@</B>,

la valeur est le nombre d'éléments dans le tableau.
<DT>
<DD>
${<I>paramètre</I><B>#</B><I>mot</I>}
<DT>${<I>paramètre</I><B>##</B><I>mot</I>}<DD>

Le
<I>mot</I>

est développé pour fournir un motif, comme dans l'expansion
des noms de fichiers. Si le motif correspond au début de la
valeur du 
<I>paramètre</I>,

alors le développement prend la valeur du
<I>paramètre</I>

après suppression du plus petit motif commun (cas ``<B>#</B>''),
ou du plus long motif (cas ``<B>##</B>'').
Si le
<I>paramètre</I>

est
<B>@</B>

ou
<B>*</B>,

l'opération de suppression de motif est appliquée à chaque paramètre
positionnel successivement, et le développement donne la liste finale.
Si le
<I>paramètre</I>

est une variable tableau indexée par
<B>@</B>

ou
<B>*</B>,

l'opération de suppression de motif est appliquée à chaque membre du
tableau successivement, et le développement donne la liste finale.
<DT>
<DD>
${<I>paramètre</I><B>%</B><I>mot</I>}
<DT>${<I>paramètre</I><B>%%</B><I>mot</I>}<DD>

est développé pour fournir un motif, comme dans l'expansion
des noms de fichiers. Si le motif correspond à une portion
finale de la valeur du
<I>paramètre</I>,

alors le développement prend la valeur du
<I>paramètre</I>

après suppression du plus petit motif commun (cas ``<B>%</B>''),
ou du plus long motif (cas ``<B>%%</B>'').
Si le
<I>paramètre</I>

est
<B>@</B>

ou
<B>*</B>,

l'opération de suppression de motif est appliquée à chaque paramètre
positionnel successivement, et le développement donne la liste finale.
Si le
<I>paramètre</I>

est une variable tableau indexée par
<B>@</B>

ou
<B>*</B>,

l'opération de suppression de motif est appliquée à chaque membre du
tableau successivement, et le développement donne la liste finale.
<DT>
<DD>
${<I>paramètre</I><B>/</B><I>motif</I><B>/</B><I>chaîne</I>}
<DT>${<I>paramètre</I><B>//</B><I>motif</I><B>/</B><I>chaîne</I>}<DD>

Le <I>motif</I> est développé comme dans le traitement des
noms de fichiers.
Le <I>paramètre</I> est développé et la plus longue portion correspondant
au <I>motif</I> est remplacée par la <I>chaîneg</I>.
Dans la première forme, seule la première correspondance est remplacée,
dans la seconde toutes les portions correspondant au <I>motif</I> sont
remplacées par la <I>chaîne</I>.
Si le <I>motif</I> commence par <B>#</B>, il doit correspondre au début 
de la valeur développée du <I>paramètre</I>.
Si le <I>motif</I> commence par <B>%</B>, il doit correspondre à la fin
du développement du <I>paramètre</I>.
Si la <I>chaîne</I> est nulle, les portions correspondant au <I>motif</I>
sont supprimées et le <B>/</B> après le <I>motif</I> peut être omis.
Si le
<I>paramètre</I>

est
<B>@</B>

ou 
<B>*</B>,

l'opération de substitution est appliquée à chacun des paramètres
positionnels successivement, et le résultat est la liste finale.
Si le
<I>paramètre</I>

est une variable tableau indexée par 
<B>@</B>

ou
<B>*</B>,

l'opération de substitution s'applique à chaque membre du tableau
successivement, et le résultat est la liste finale.
</DL>
<A NAME="lbBA">&nbsp;</A>
<H3>Substitution de commandes</H3>

<P>

La <I>substitution de commandes</I> permet de remplacer le nom
d'une commande par son résultat. Il en existe deux formes :
<P>

<DL COMPACT><DT><DD>
<P>

<B>$(</B><I>commande</I><B>)</B>
</DL>

ou
<DL COMPACT><DT><DD>
<B>`</B><I>commande</I><B>`</B>
</DL>

<P>

<B>Bash</B>

effectue la substitution en exécutant la <I>commande</I> et en
la remplaçant par sa sortie standard, dont les derniers sauts de
lignes sont supprimés.
Les sauts de lignes internes ne sont pas supprimés mais peuvent disparaître
lors du découpage en mots.
La substitution de commande <B>$(cat </B><I>fichier</I>) peut être remplacée par
l'équivalent plus rapide <B>$(&lt; </B><I>fichier</I>).
<P>

Quand l'ancienne forme de substitution avec les backquotes ` est utilisée,
le caractère antislash garde sa signification littérale, sauf s'il est suivi de
<B>$</B>,

<B>`</B>,

ou
<B>\</B>.

La première backquote non protégée par un antislash termine la
substitution de commande.
Quand on utilise la forme $(<I>commande</I>), tous les caractères entre
parenthèses gardent leurs valeurs littérales. Aucun n'est traité spécialement.
<P>

Les substitutions de commandes peuvent être imbriquées. Avec l'ancienne
forme, il faut protéger les backquotes internes avec un backslash.
<P>

Si la substitution apparaît entre guillemets, le découpage des mots,
et l'expansion des noms de fichiers ne sont pas effectués.
<A NAME="lbBB">&nbsp;</A>
<H3>Évaluation Arithmétique</H3>

<P>

L'évaluation arithmétique permet de remplacer une expression par le résultat
de son évaluation. Le format d'évaluation arithmétique est :
<DL COMPACT><DT><DD>
<P>

<B>$((</B><I>expression</I><B>))</B>
</DL>

<P>

L'<I>expression</I>

est manipulée de la même manière que 
si elle se trouvait entre guillemets, mais un guillemet se trouvant entre
les parenthèses n'est pas traité spécifiquement.
Tous les mots de l'expression subissent le développement des paramètres,
la substitution des commandes et la suppression des apostrophes et guillemets.
Les évaluations arithmétiques peuvent être imbriquées.
<P>

L'évaluation est effectuée en suivant les règles mentionnées dans le paragraphe
<FONT SIZE="-1"><B>CALCUL</B>ARITHMÉTIQUE<B>.</B>

</FONT>
Si
l'<I>expression</I>

est invalide,
<B>bash</B>

affiche un message indiquant l'erreur, et aucune substitution n'a lieu.
<A NAME="lbBC">&nbsp;</A>
<H3>Substitution de Processus</H3>

<P>

La <I>substitution de processus</I> n'est disponible que sur les systèmes
acceptant le mécanisme des tubes nommés (<I>FIFOs</I>) ou la méthode
<B>/dev/fd</B> de noms de fichiers  Elle prend la forme
<B>&lt;(</B><I>liste</I><B>)</B>
ou
<B>&gt;(</B><I>liste</I><B>)</B>.
La <I>liste</I> de processus est exécutée avec ses entrées et sorties connectée
à une <I>FIFO</I> ou à un fichier dans <B>/dev/fd</B>.  Le nom de ce fichier est
passé en argument à la commande qui sera exécutée comme résultat de cette
substitution. Si on utilise la forme <B>&gt;(</B><I>liste</I><B>)</B>, l'écriture
dans le fichier fournira des entrées pour la <I>liste</I>. Si la
forme <B>&lt;(</B><I>liste</I><B>)</B> est utilisée, le fichier passe
en argument devra être lu pour obtenir la sortie de la <I>liste</I>.
<P>

Sur les systèmes qui le permettent, la <I>substitution de processus</I>
est effectuée simultanément au remplacement des paramètres et variables,
a la substitution de commande,
et à l'évaluation arithmétique.
<A NAME="lbBD">&nbsp;</A>
<H3>Séparation des mots</H3>

<P>

Les résultats du
remplacement des paramètres,
de la substitution de commandes, 
et 
de l'évaluation arithmétique, qui ne se trouvent
pas entre guillemets sont analysés par le shell afin d'appliquer le
<I>découpage des mots</I>.

<P>

L'interpréteur considère chaque caractère du paramètre
<FONT SIZE="-1"><B>IFS</B>

</FONT>
comme un délimiteur, et redécoupe le résultat des transformations
précédentes en fonction de ceux-ci. Si la valeur du paramètre
<FONT SIZE="-1"><B>IFS</B>

</FONT>
est
exactement
<B>&lt;espace&gt;&lt;tabulation&gt;&lt;retour-chariot&gt;</B>,

(la valeur par défaut), alors toute séquence de
caractères
<FONT SIZE="-1"><B>IFS</B>

</FONT>
sert à délimiter les mots. Si
<FONT SIZE="-1"><B>IFS</B>

</FONT>
a une valeur autre que celle par défaut, alors les
séquences de caractères blancs
<B>espace</B>

et
<B>tabulation</B>

sont ignorées en début et fin de mot, à condition que
ces caractères blancs se trouvent dans
la valeur de
<FONT SIZE="-1"><B>IFS</B>

</FONT>
(un caractère de
<FONT SIZE="-1"><B>IFS</B>

</FONT>
blanc).
Tout autre caractère de
<FONT SIZE="-1"><B>IFS</B>

</FONT>
se trouvant
à côté d'un
caractère
blanc de
<FONT SIZE="-1"><B>IFS</B>,

</FONT>
sert à délimiter un champ.
Une séquence de caractères blancs de
<FONT SIZE="-1"><B>IFS</B>

</FONT>
est également traitée comme un séparateur.
Si la valeur de
<FONT SIZE="-1"><B>IFS</B>

</FONT>
est nulle, aucun découpage de mot n'a lieu.
<P>

Les arguments nuls explicites (<B>&quot;&quot;</B> ou <B>''</B>)
sont conservés. Les arguments nuls implicites, résultant du développement des
<I>paramètres</I>

n'ayant pas de valeurs, sont éliminés.
Si un paramètre sans valeur est développé entre guillemets, le résultat
est un argument nul qui est conservé.
<P>

Notez que si aucun développement n'a lieu, le découpage des mots n'est
pas effectué.
<A NAME="lbBE">&nbsp;</A>
<H3>Développement des noms de fichiers</H3>

<P>

Après le découpage des mots,
et si l'option
<B>-f</B>

n'est pas indiquée,
<B>bash</B>

recherche dans chaque mot les caractères
<B>*</B>,

<B>?</B>,

<B>(</B>,

et
<B>[</B>.

Si l'un d'eux apparaît, le mot est considéré
comme un
<I>motif</I>,

et remplacé par une liste, classée par ordre alphabétique,
des noms de fichiers correspondant à ce motif.
Si aucun nom de fichiers ne correspond,
et si l'option shell
<B>nullglob</B>

n'est pas active, le mot reste inchangé.
Si l'option
<B>nullglob</B>

est active, et si aucune correspondance n'est trouvée,
le mot est supprimé.
Si l'option shell
<B>nocaseglob</B>

est activée, la correspondance a lieu sans tenir compte
des différences majuscules / minuscules.
Quand un motif est utilisé pour créer des chemins d'accès,
le caractère
<B>``.''</B>

au début d'un nom, ou immédiatement à la suite d'un slash
doit être explicitement mis en correspondance, à moins que l'option shell
<B>dotglob</B>

ne soit active.
Le caractère slash doit toujours être mis en correspondance
explicitement.
Dans tous les autres cas, le caractère
<B>``.''</B>

n'est pas traité spécifiquement.
Voyez la description de la commande
<B>shopt</B>

dans
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
pour une description des options
shell
<B>nocaseglob</B>,

<B>nullglob</B>,

et
<B>dotglob</B>.

<P>

la variable shell
<FONT SIZE="-1"><B>GLOBIGNORE</B>

</FONT>
peut servir à restreindre l'ensemble des noms de fichiers correspondant à un
<I>motif</I>.

Si
<FONT SIZE="-1"><B>GLOBIGNORE</B>

</FONT>
est remplie, chaque nom de fichier qui correspond aussi à un motif de
<FONT SIZE="-1"><B>GLOBIGNORE</B>

</FONT>
est supprimé de la liste des correspondances.
Les noms de fichiers
<B>``.''</B>

et 
<B>``..''</B>

sont toujours ignorés, même quand
<FONT SIZE="-1"><B>GLOBIGNORE</B>

</FONT>
est remplie. Toutefois, configurer
<FONT SIZE="-1"><B>GLOBIGNORE</B>

</FONT>
a pour effet d'activer l'option shell
<B>dotglob</B>,

ainsi tous les autres noms de fichiers commençant par 
<B>``.''</B>

correspondront.
Pour obtenir l'ancien comportement ignorant les noms commençant par
<B>``.''</B>,

placez
<B>``.*''</B>

dans l'un des motifs de
<FONT SIZE="-1"><B>GLOBIGNORE</B>.

</FONT>
L'option
<B>dotglob</B>

est désactivée si la variable
<FONT SIZE="-1"><B>GLOBIGNORE</B>

</FONT>
n'existe pas.
<P>

<B>Motifs génériques</B>
<P>

Tout caractère apparaissant dans un motif, hormis les caractères spéciaux
décrits ci-après correspond à lui-même. Le caractère NUL ne peut pas se
trouver dans un motif. Les caractères spéciaux doivent être protégés si
ils doivent se correspondre littéralement.
<P>

Les caractères spéciaux ont les significations suivantes :
<P>


<DL COMPACT>
<DT><B>*</B>

<DD>
Correspond à n'importe quelle chaîne, y compris la chaîne vide.
<DT><B>?</B>

<DD>
Correspond à n'importe quel caractère.
<DT><B>[...]</B>

<DD>
Correspond à l'un des caractères entre crochets. Une paire de
caractères séparés par un signe &quot;moins&quot; indique un
<I>intervalle</I>;

qui correspond à n'importe quel caractère situé entre les
deux bornes incluses. Si le premier caractère suivant le
<B>[</B>

est un
<B>!</B>

ou un
<B>^</B>

alors la correspondance se fait sur les caractères non-inclus.
Un
<B>-</B>

peut être mis en correspondance en l'incluant en premier
ou dernier caractère de l'ensemble.
Un
<B>]</B>

peut être mis en correspondance en l'incluant en premier
caractère de l'ensemble.
<BR>


<P>

Entre
<B>[</B>

et
<B>]</B>,

on peut indiquer une <I>classe de caractère</I> en utilisant la syntaxe
<B>[:</B><I>classe</I><B>:]</B>, où <I>classe</I> est l'une des
classes suivantes, définies dans le standard POSIX.2 :
</DL>
<P>

<DL COMPACT><DT><DD>
<B>alnum alpha ascii blank cntrl digit graph lower print punct space upper xdigit
</B>


<BR>

Une classe correspond à un caractère quelconque qui s'y trouve.
<BR>


<P>

Entre
<B>[</B>

et
<B>]</B>,

on peut indiquer une <I>classe d'équivalence</I> en utilisant la syntaxe
<B>[=</B><I>c</I><B>=]</B>, qui correspond à n'importe quel caractère ayant
le même ordre (comme indiqué dans la localisation en cours) que
le caractère <I>c</I>.
<BR>


<P>

Entre 
<B>[</B>

et  
<B>]</B>,

la syntaxe <B>[.</B><I>symbole</I><B>.]</B> correspond au symbole de classement
<I>symbole</I>.
</DL>


<P>

Si l'option <B>extglob</B> du shell option est activée par la commande <B>shopt</B>
plusieurs opérateurs de correspondance étendue sont reconnus.
Dans la description suivante, une <I>liste-motif</I> est une liste d'un
ou plusieurs motifs séparés par des <B>|</B>.
Les motifs composés sont formés en utilisant un ou plusieurs sous-motifs
comme suit :
<P>

<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>?(</B><I>liste-motif</I><B>)</B><DD>
Correspond à zéro ou une occurrence des motifs indiqués
<DT><B>*(</B><I>liste-motif</I><B>)</B><DD>
Correspond à zéro ou plusieurs occurrences des motifs indiqués
<DT><B>+(</B><I>liste-motif</I><B>)</B><DD>
Correspond à une ou plusieurs occurrences des motifs indiqués
<DT><B>@(</B><I>liste-motif</I><B>)</B><DD>
Correspond à une occurrence exactement des motifs indiqués
<DT><B>!(</B><I>liste-motif</I><B>)</B><DD>
Correspond à tout sauf les motifs indiqués
</DL>
</DL>


<A NAME="lbBF">&nbsp;</A>
<H3>Suppression des protections</H3>

<P>

Après les développements précédents, toutes les occurrences non-protégées
des caractères
<B>\</B>,

<B>`</B>,

et <B>&quot;</B> qui ne résultent pas d'un développement
sont supprimées.
<A NAME="lbBG">&nbsp;</A>
<H2>REDIRECTION</H2>

Avant qu'une commande ne soit exécutée,
il est possible de
<I>rediriger</I>

son entrée et sa sortie en utilisant une notation spéciale interprétée par
le shell. Les redirections peuvent également servir à ouvrir ou fermer des
fichiers dans l'environnement actuel du shell. Les opérateurs de redirection
décrits ci-dessous peuvent apparaître avant, ou au sein d'une 
<I>commande simple</I>

ou suivre une
<I>commande</I>.

Les redirections sont traitées dans l'ordre d'apparition
de gauche à droite.
<P>

Dans les descriptions suivantes, si le numéro de descripteur de fichier est
omis, et si le premier caractère de l'opérateur de redirection est
<B>&lt;</B>,

celui-ci correspondra à l'entrée standard (descripteur de fichier 0).
Si le premier caractère de l'opérateur est
<B>&gt;</B>,

la redirection s'appliquera à la sortie standard (descripteur de
fichier 1).
<P>

Le mot qui suit l'opérateur de redirection dans les descriptions
suivantes est soumis à l'expansion des accolades, du tilde,
des paramètres, à la substitution de commandes, à l'évaluation
arithmétique, à la suppression des protections, et au développement
des noms de fichiers. S'il se modifie pour donner plusieurs mots,
<B>bash</B>

détectera une erreur.
<P>

Remarquez que l'ordre des redirections est important. Par exemple,
la commande
<DL COMPACT><DT><DD>
<P>

ls <B>&gt;</B> liste_répertoires 2<B>&gt;&amp;</B>1
</DL>

<P>

redirige a la fois la sortie standard et la sortie d'erreur vers le fichier
<I>liste_répertoires</I>,

alors que la commande
<DL COMPACT><DT><DD>
<P>

ls 2<B>&gt;&amp;</B>1 <B>&gt;</B> liste_répertoires
</DL>

<P>

ne redirige que la sortie standard vers le fichier
<I>liste_répertoires</I>,

car la sortie d'erreur a été renvoyée vers la sortie standard
avant que celle-ci ne soit redirigée vers
<I>liste_répertoires</I>.

<P>

Une erreur d'ouverture ou de création de fichier peut déclencher un échec.
<A NAME="lbBH">&nbsp;</A>
<H3>Redirection d'entrée</H3>

<P>

Lorsque l'on applique une redirection d'entrée, le fichier dont
le nom résulte du développement du
<I>mot</I>

sera ouvert en lecture avec le descripteur de fichier numéro
<I>n</I>,

ou en tant qu'entrée standard (descripteur de fichier 0) si
<I>n</I>

n'est pas mentionné.
<P>

Le format général des redirections d'entrée est le suivant :
<DL COMPACT><DT><DD>
<P>

[<I>n</I>]<B>&lt;</B><I>mot</I>
</DL>

<A NAME="lbBI">&nbsp;</A>
<H3>Redirection de sortie</H3>

<P>

Lors d'une redirection de sortie, le fichier dont le nom résulte
du développement du
<I>mot</I>

est ouvert en écriture, avec le descripteur de fichier
<I>n</I>,

ou en tant que sortie standard (descripteur de fichier 1) si
<I>n</I>

n'est pas mentionné. Si le fichier n'existe pas, il est créé.
S'il existait déjà, sa taille est ramenée à 0.
<P>

Le format général des redirections de sortie est le suivant :
<DL COMPACT><DT><DD>
<P>

[<I>n</I>]<B>&gt;</B><I>mot</I>
</DL>

<P>

Si l'opérateur de redirection est
<B>&gt;</B>,

et si l'option
<B>noclobber</B>

de la commande interne
<B>set</B>

est activée, la redirection échouera si le fichier dont le nom
résulte du développement du <I>mot</I> existe et est un 
fichier régulier.
Si l'opérateur de redirection est
<B>&gt;|</B>,

ou l'opérateur
<B>&gt;</B>

avec l'option
<B>noclobber</B>

de la commande interne
<B>set</B>

n'est pas activée, la redirection sera tentée même si le fichier dont le nom
résulte du développement du <I>mot</I> existe.
<A NAME="lbBJ">&nbsp;</A>
<H3>Redirection pour Ajout en Sortie</H3>

<P>

Lorsqu'on redirige ainsi la sortie, 
le fichier dont le nom résulte
du développement du
<I>mot</I>

est ouvert pour ajout en fin de fichier, avec le descripteur
<I>n</I>,

ou en tant que sortie standard (descripteur 1) si
<I>n</I>

n'est pas mentionné. Si le fichier n'existe pas, il est créé.
<P>

Le format général pour la redirection de sortie avec ajout est :
<DL COMPACT><DT><DD>
<P>

[<I>n</I>]<B>&gt;&gt;</B><I>mot</I>
</DL>

<P>

<A NAME="lbBK">&nbsp;</A>
<H3>Redirection de la sortie standard et de la sortie d'erreur</H3>

<P>

<B>Bash</B>

permet la redirection simultanée de la sortie standard (descripteur 1)
et de la sortie d'erreur (descripteur 2),
dans un fichier dont le nom
est le résultat du
développement du
<I>mot</I>

avec cette construction.
<P>

Il y a deux formes pour effectuer cette double
redirection :
<DL COMPACT><DT><DD>
<P>

<B>&amp;&gt;</B><I>mot</I>
</DL>

et
<DL COMPACT><DT><DD>
<B>&gt;&amp;</B><I>mot</I>
</DL>

<P>

On préfère généralement la première.
Elle est sémantiquement équivalente à
<DL COMPACT><DT><DD>
<P>

<B>&gt;</B><I>mot</I> 2<B>&gt;&amp;</B>1
</DL>

<A NAME="lbBL">&nbsp;</A>
<H3>Document en ligne</H3>

<P>

Avec ce type de redirection, le shell va lire son entrée standard
jusqu'à ce qu'il atteigne une ligne contenant uniquement le
<I>mot</I>

prévu (sans espaces à la suite), nommée <I>étiquette</I>. Une fois cette
étiquette atteinte, il exécutera la commande demandée en lui fournissant en
entrée le texte lu avant l'étiquette,
que l'on appelle <I>document en ligne</I>.
<P>

Le format des documents en ligne est le suivant :
<DL COMPACT><DT><DD>
<P>

<PRE>
<B>&lt;&lt;</B>[<B>-</B>]<I>mot</I>
        <I>document en ligne</I>
<I>étiquette</I>
</PRE>

</DL>

<P>

Il n'y a ni remplacement de paramètre, ni substitution de commande,
ni développement de chemin d'accès, ni évaluation arithmétique sur le
<I>mot</I>.

Si l'un des caractères du
<I>mot</I>

est protégé, 
l' étiquette

est obtenue après suppression des protections dans le
<I>mot</I>,

et les lignes du document ne sont pas développées. Sinon,
toutes les lignes du document sont soumises au remplacement des paramètres,
à la substitution de commandes, et à l'évaluation arithmétique.
Dans ce
dernier cas, les couples
<B>\&lt;retour-chariot&gt;</B>

sont ignorés, et
<B>\</B>

doit être utilisé pour protéger les caractères
<B>\</B>,

<B>$</B>,

et
<B>`</B>.

<P>

Si l'opérateur de redirection est
<B>&lt;&lt;-</B>,

alors les tabulations en tête de chaque ligne sont supprimées, y compris
dans la ligne contenant 
<I>étiquette</I>.

Ceci permet d'indenter de manière naturelle les
documents en ligne au sein
des scripts.
<A NAME="lbBM">&nbsp;</A>
<H3>Dédoublement de descripteur de fichier</H3>

<P>

L'opérateur de redirection
<DL COMPACT><DT><DD>
<P>

[<I>n</I>]<B>&lt;&amp;</B><I>mot</I>
</DL>

<P>

permet de dupliquer les descripteurs de fichiers en entrée.
Si le
<I>mot</I>

se transforme en un ou plusieurs chiffres, le descripteur de fichier
<I>n</I>

devient une copie de ce descripteur.
Si les chiffres du
<I>mot</I>

ne correspondent pas à un descripteur en lecture, une erreur se produit.
Si le
<I>mot</I>

prend la forme
<B>-</B>,

le descripteur
<I>n</I>

est fermé.  Si
<I>n</I>

n'est pas mentionné, on utilise l'entrée standard (descripteur 0).
<P>

L'opérateur
<DL COMPACT><DT><DD>
<P>

[<I>n</I>]<B>&gt;&amp;</B><I>mot</I>
</DL>

<P>

est utilisé de manière similaire pour dupliquer les descripteurs de sortie. Si
<I>n</I>

n'est pas précisé, on considère la sortie standard (descripteur 1).
Si les chiffres du
<I>mot</I>

ne correspondent pas à un descripteur en écriture, une erreur se produit.
Un cas particulier se produit si <I>n</I> est omis, et si <I>mot</I> ne se
développe pas sous forme de chiffres. Alors, les sorties standard et
d'erreurs sont toutes deux redirigées comme précédemment.
<A NAME="lbBN">&nbsp;</A>
<H3>Ouverture en Lecture/Écriture d'un descripteur de fichier</H3>

<P>

L'opérateur de redirection
<DL COMPACT><DT><DD>
<P>

[<I>n</I>]<B>&lt;&gt;</B><I>mot</I>
</DL>

<P>

ouvre le fichier dont le nom résulte du développement du
<I>mot</I>,

à la fois en lecture et en écriture et lui affecte le descripteur de fichier
<I>n</I>,

ou bien le descripteur 0 si
<I>n</I>

n'est pas mentionné. Si le fichier n'existe pas, il est créé.
<A NAME="lbBO">&nbsp;</A>
<H2>ALIAS</H2>

Les alias permettent de substituer une chaîne à un mot lorsqu'il est utilisé
comme premier mot d'une commande simple.
L'interpréteur gère une liste
d'<I>alias</I>

qui peuvent être créés et détruits avec les commandes internes
<B>alias</B>

et
<B>unalias</B>

(voir le paragraphe
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas).
Le shell vérifie si le premier mot de chaque commande (s'il n'est pas protégé)
est un alias. Si tel est le cas, ce mot est remplacé par le texte de l'alias.
Le nom de l'alias, ainsi que le texte de remplacement,
peuvent contenir n'importe quels caractères valides pour le shell,
y compris les
<I>méta-caractères</I>

présentés plus haut. Une exception toutefois, le nom de l'alias ne peut pas
contenir de caractère <I>=</I>. Le shell vérifie si le premier mot du texte
de remplacement est à son tour le nom d'un alias, mais s'il est identique au
nom de l'alias il ne sera pas remplacé à nouveau. Ceci permet de créer un alias
<B>ls</B>

valant
<B>ls -F</B>,

par exemeple, que
<B>bash</B>

n'essaiera pas de développer récursivement.
Si le dernier caractère du texte de remplacement est un
<I>blanc</I>,

alors on vérifiera également si le mot suivant
l'alias est lui aussi un alias.
<P>

Les alias sont créés et affichés avec la commande
<B>alias</B>,

et supprimés avec
la commande
<B>unalias</B>.

<P>

Il n'existe pas de mécanisme permettant d'utiliser des arguments dans le texte
de remplacement. Si on en a besoin, il faut utiliser une fonction du shell.
<P>

Les alias ne sont développés qu'avec les shells interactifs sauf si
l'option
<B>expand_aliases</B>

du shell est activée par la commande
<B>shopt</B>

(voir la description de
<B>shopt</B>

au paragraphe
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B></FONT>
plus bas)
<P>

Les règles concernant la définition et l'utilisation des alias sont un peu
confuses.
<B>Bash</B>

lit toujours au moins une ligne d'entrée complètement avant d'exécuter une
commande de cette ligne. Les alias sont traités lorsque la commande est
lue, et non pas lorsqu'elle est exécutée. Ainsi, une définition d'alias
apparaissant sur la même ligne qu'une autre commande ne prend pas effet
avant la lecture de la prochaine ligne d'entrée.
Autrement dit, une commande placée à la suite d'une définition d'alias,
sur la même ligne ne sera pas
affectée par cet alias.
Ce comportement est également important lors de l'exécution des fonctions.
Les alias sont traités lorsque la définition de la fonction est lue,
et non pas lors de l'exécution de cette fonction. Ainsi des alias
définis dans une fonction ne sont pas actifs avant la fin de l'exécution
de la fonction. Pour plus de tranquillité, placez
toujours les définitions d'alias sur des lignes isolées, et n'utilisez
jamais la commande
<B>alias</B>

dans les commandes composées.
<P>

Notez enfin que la plupart du temps les alias sont avantageusement remplacés
par des fonctions du shell.
<A NAME="lbBP">&nbsp;</A>
<H2>FONCTIONS</H2>

Une fonction du shell mémorise une série de commandes pour permettre une
exécution ultérieure. Leurs definition est décrite plus haut, dans 
<FONT SIZE="-1"><B>GRAMMAIRE</B>DU<B>SHELL</B>.

</FONT>
Les fonctions sont exécutées dans le contexte de l'interpréteur en cours.
On ne crée pas de nouveau processus pour interpréter une fonction, 
contrairement à l'exécution d'un script.
Les arguments d'une fonction sont placés dans les paramètres positionnels
durant son exécution.
Le paramètre spécial
<B>#</B>

est mis a jour. Le paramètre positionnel 0 n'est pas
modifié. Les autres aspects de l'environnement d'exécution
du shell sont identiques entre l'intérieur de la fonction et le
corps appelant du programme, à l'exception de la gestion de
<FONT SIZE="-1"><B>DEBUG</B>

</FONT>
(voir la description de la commande interne
<B>trap</B>

au paragraphe
<FONT SIZE="-1"><B>SHELL BUILTIN COMMANDS</B>

</FONT>
plus bas) qui n'est pas héritée.
<P>

Les variables locales d'une fonction peuvent être déclarées avec la commande
<B>local</B>.

Autrement, les variables et leurs valeurs sont partagées entre la
fonction et son appelant.
<P>

Si la commande interne
<B>return</B>

est exécutée dans une fonction, celle-ci se termine et l'exécution reprend
avec la commande suivant l'appel de fonction.
Quand une fonction se termine, les paramètres positionnels et le
paramètre spécial
<B># </B>

reprennent les valeurs qu'ils avaient avant l'appel de
fonction.
<P>

Les noms des fonctions et leurs définitions sont affichés avec l'option
<B>-f</B>

des commandes internes
<B>declare</B>

ou
<B>typeset</B>.

Les options
<B>-F</B>

de
<B>declare</B>

ou
<B>typeset</B>

n'afficheront que les noms des fonctions.
Les fonctions peuvent être exportées
automatiquement avec l'option
<B>-f</B>

de la commande interne
<B>export</B>,

afin de rester définies dans les sous-shells.
<P>

Les fonctions peuvent être récursives. Aucune limite n'est imposée quant
au nombre d'appels récursifs.
<A NAME="lbBQ">&nbsp;</A>
<H2>CALCUL ARITHMÉTIQUE</H2>

Le shell permet, dans certaines circonstances, l'évaluation d'expressions
arithmétiques (voir la commande interne <B>let</B> ainsi que le paragraphe
<B>Évaluation Arithmétique</B>).
L'évaluation est effectuée en utilisant des entiers longs, sans vérification
du débordement.  Néanmoins la division par 0 est détectée et renvoie une erreur.
La liste des opérateurs ci-dessous est constituée par des groupes de précédence
identique.
Les niveaux sont classés en ordre de précédence décroissante.
<P>


<DL COMPACT>
<DT><B>- +</B>

<DD>
plus et moins unaire
<DT><B>! ~</B>

<DD>
négations logique et binaire
<DT><B>**</B>

<DD>
exponentiation
<DT><B>* / %</B>

<DD>
multiplication, division, reste
<DT><B>+ -</B>

<DD>
addition, soustraction
<DT><B>&lt;&lt; &gt;&gt;</B>

<DD>
décalage arithmétique à gauche et à droite
<DT><B>&lt;= &gt;= &lt; &gt;</B>

<DD>
comparaisons
<DT><B>== !=</B>

<DD>
égalité et différence
<DT><B>&amp;</B>

<DD>
ET binaire
<DT><B>^</B>

<DD>
OU exclusif binaire
<DT><B>|</B>

<DD>
OU binaire
<DT><B>&amp;&amp;</B>

<DD>
ET logique
<DT><B>||</B>

<DD>
OU logique
<DT><B></B><I>expr</I>?<I>expr</I>:<I>expr</I>

<DD>
évaluation conditionnelle
<DT><B>= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</B>

<DD>
assignations

</DL>
<P>

On peut utiliser les variables du shell comme opérandes, le développement
des paramètres étant effectué avant l'évaluation arithmétique.
Les valeurs des paramètres sont converties en entiers longs dans les
expressions. Une variable shell n'a donc pas besoin d'avoir l'attribut
&quot;entier&quot; pour être utilisable dans un calcul.
<P>

Les constantes commençant par un 0 sont interprétées comme des nombres
octaux. Un entête <I>0x</I> ou <I>0X</I> indique une valeur hexadécimale.
Sinon, les nombres ont la forme [<I>base#</I>]n, ou la <I>base</I> arithmétique
est un nombre décimal entre 2 et 36, et <I>n</I> le nombre lui-même exprimé
dans cette base. Si la <I>base</I> n'est pas mentionnée, le nombre est
considéré comme décimal.
Les chiffre supérieurs à 9 sont représentés par les lettres minuscules,
les lettres majuscules, le _ et le @, dans cet ordre.
Si la <I>base</I> est inférieure ou égale à 36 les minuscules et les majuscules
peuvent être utilisées de manière interchangeable pour représenter les nombres
entre 10 et 35.
<P>

Les opérateurs sont évalués dans l'ordre de précédence. Les sous-expressions
entre parenthèses sont évaluées en premier, ce qui permet de surpasser les
règles de précédence.
<A NAME="lbBR">&nbsp;</A>
<H2>EXPRESSIONS CONDITIONNELLES</H2>

Les expressions conditionnelles sont utilisées par la commande composée <B>[[</B>
et les commandes internes <B>test</B> et <B>[</B> pour vérifier l'état d'un fichier
et assurer des comparaisons arithmétiques ou sur des chaînes.
Les expressions se forment à partir des opérateurs unaires ou binaires suivants.
Si un argument <I>fichier</I> est de la forme
/dev/fd/<I>n</I>, alors il représente le descritpeur de fichier <I>n</I>.
<P>

<DL COMPACT>
<DT><B>-a </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe.
<DT><B>-b </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et est un fichier spécial bloc.
<DT><B>-c </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et est un fichier spécial caractère.
<DT><B>-d </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et est un répertoire
<DT><B>-e </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe.
<DT><B>-f </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et est un fichier régulier.
<DT><B>-g </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et a son bit Set-GID positionné.
<DT><B>-h </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et est un lien symbolique.
<DT><B>-k </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et a son bit ``sticky'' positionné.
<DT><B>-p </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et est un tube nommé (FIFO).
<DT><B>-r </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et est accessible en lecture.
<DT><B>-s </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et a une taille non nulle.
<DT><B>-t </B><I>fd</I>

<DD>
Vrai si
<I>fd</I>

est ouvert sur un terminal.
<DT><B>-u </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et a son bit Set-UID positionné.
<DT><B>-w </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et est accessible en écriture.
<DT><B>-x </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et est exécutable.
<DT><B>-O </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et appartient à l'ID effectif de l'utilisateur.
<DT><B>-G </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et appartient au groupe effectif de l'utilisateur.
<DT><B>-L </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et est un lien symbolique.
<DT><B>-S </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et est une socket
<DT><B>-N </B><I>fichier</I>

<DD>
Vrai si le <I>fichier</I> existe et a été modifié depuis sa dernière lecture.
<DT><I>fichier_1</I> -<B>nt</B> <I>fichier_2</I><DD>
Vrai si le <I>fichier_1</I> est plus récent que le <I>fichier_2</I>, d'après
les dates de modification.
<DT><I>fichier_1</I> -<B>ot</B> <I>fichier_2</I><DD>
Vrai si le <I>fichier_1</I> est plus vieux que le fichier_2.
<DT><I>fichier_1</I> <B>-ef</B> <I>fichier_2</I><DD>
Vrai si le<I>fichier_1</I> et le <I>fichier_2</I> sont sur le même périphérique et
ont les mêmes numéros d'i-noeuds.
<DT><B>-o </B><I>nom_opt</I>

<DD>
Vrai si l'option shell
<I>nom_opt</I>

est active.
Cosulter la liste des options dans la description de l'argument
<B>-o</B>

de la commande interne
<B>set</B>

plus bas.
<DT><B>-z </B><I>chaîne</I>

<DD>
Vrai si la longueur de la <I>chaîne</I> est nulle.
<DT><B>-n </B><I>chaîne</I>

<DD>
<DT><I>chaîne</I><DD>
Vrai si la longueur de la
<I>chaîne</I>

est non-nulle.
<DT><I>chaîne_1</I> <B>==</B> <I>chaîne_2</I><DD>
Vrai si les deux chaînes sont égales. Le symbole <B>=</B> peut servir à
remplacer <B>==</B>
<DT><I>chaîne_1</I> <B>!=</B> <I>chaîne_2</I><DD>
Vrai si les deux chaînes sont différentes.
<DT><I>chaîne_1</I> <B>&lt;</B> <I>chaîne_2</I><DD>
Vrai si <I>chaîne_1</I> se trouve avant <I>chaîne_2</I> dans l'ordre
lexicographique de la localisation en cours.
<DT><I>chaîne_1</I> <B>&gt;</B> <I>chaîne_2</I><DD>
Vrai si <I>chaîne_1</I> se trouve après <I>chaîne_2</I> dans l'ordre
lexicographique de la localisation en cours.
<DT><I>arg1 </I><B>OP</B> arg2

<DD>
<FONT SIZE="-1"><B>OP</B>

</FONT>
est l'un des opérateurs suivants
<B>-eq</B>,

<B>-ne</B>,

<B>-lt</B>,

<B>-le</B>,

<B>-gt</B>,

ou
<B>-ge</B>.

Ces opérateurs arithmétiques binaires renvoient la valeur
vraie si <I>arg_1</I> est respectivement égal, différent,
inférieur, inférieur ou égal, supérieur, supérieur ou égal à <I>arg2</I>.
<I>Arg1</I>

et
<I>arg2</I>

peuvent être des entiers positifs ou négatifs.

</DL>
<A NAME="lbBS">&nbsp;</A>
<H2>DÉVELOPPEMENT DES COMMANDES SIMPLES</H2>

Lors de l'exécution d'une commande simple, le shell effectue les développements
affectations, et redirections de gauche à droite, suivants.
<DL COMPACT>
<DT>1.<DD>
Les mots que l'analyser a repéré comme affectation de variables (ceux qui
précèdent le nom de la commande) et les redirections sont mémorisés pour
une mise en place ultérieure.
<DT>2.<DD>
Les autres mots sont développés. S'il reste des mots après le
développement, le premier est considéré comme le nom d'une commande
et les suivants comme ses
arguments.
<DT>3.<DD>
Les redirections sont mises en place, comme décrit plus-haut au paragraphe
<FONT SIZE="-1"><B>REDIRECTION</B>.

</FONT>
<DT>4.<DD>
Le texte suivant le <B>=</B> dans chaque affectation est soumis au dévelopement
du tilde, des paramètres, à la substitution de commande, à l'évaluation
arithmétique et à la suppression des protection avant de remplir la variable.
</DL>
<P>

Si aucun nom de commande ne résulte des précédentes opérations, les assignations
de variable modifie l'environnement en cours. Sinon elles sont ajoutées à celui
de la commande exécutée et ne modifient pas l'environnement du shell.
Si l'une des tentatives d'affectation concerne une variable en lecture seule,
une erreur se produit, et la commande se termine sur un code non-nul.
<P>

Si aucun nom de commande n'est obtenu, les redirections sont réalisées
mais ne modifient pas l'environnement du shell en cours. Une erreur de
redirection renvoie un code de retour non-nul.
<P>

S'il reste un nom de commande après l'expansion, l'exécution a lieu comme décrit
ci-dessous. Sinon la commande se termine. Si l'un des développement contient une
substitution de commande, le code de retour est celui de la dernière
substitution de commande réalisée. S'il n'y en a pas, la commande
se termine avec un code de retour nul.
<A NAME="lbBT">&nbsp;</A>
<H2>EXÉCUTION DES COMMANDES</H2>

Après le découpage de la ligne de commande en mots, si le résultat
est une commande simple suivie d'une éventuelle liste d'arguments,
les actions suivantes sont effectuées.
<P>

Si le nom de la commande ne contient pas de slash, le shell tente
de la trouver. S'il existe une fonction shell de ce nom, elle est
appelée comme nous l'avons vu dans le paragraphe
<FONT SIZE="-1"><B>FONCTIONS</B>

</FONT>
plus haut. Si le nom n'est pas celui d'une fonction, l'interpréteur le
recherche dans la liste des fonctions internes. Si une équivalence
est trouvée, la fonction interne est invoquée.
<P>

Si le nom n'est ni celui d'une fonction shell, ni celui d'une
commande interne, et s'il ne contient pas de slash,
<B>bash</B>

va chercher dans chacun des membres de
<FONT SIZE="-1"><B>PATH</B>

</FONT>
un répertoire contenant un fichier exécutable du nom désiré.
<B>Bash</B>

utilise une table de hachage pour mémoriser les noms d'accès complets
des fichiers (voir la commande
<B>hash</B>

au paragraphe
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas).
Une recherche complète dans les répertoires du
<FONT SIZE="-1"><B>PATH</B>

</FONT>
n'est entreprise que si la commande ne se trouve pas dans la table de hachage.
Si la recherche est infructueuse, l'interpréteur affiche un
message d'erreur et renvoie un code de retour valant 127.
<P>

Si la recherche réussit, ou si le nom de la commande contient
au moins un slash, le shell exécute le programme voulu
dans un environnement distinct.
L'argument 0 est rempli avec le nom fourni, et les autres arguments seront
éventuellement remplis avec le reste de la ligne de commande.
<P>

Si l'exécution échoue parce que le programme n'est pas un exécutable,
et si le fichier n'est pas un répertoire, on le considère alors
comme un <I>script shell</I>, un fichier contenant une série de commandes.
Un sous-shell est alors créé pour exécuter ce script.
Ce sous-shell se réinitialisera lui-même, comme si un nouveau shell avait
été invoqué pour exécuter le script, à la différence qu'il continuera à
mémoriser l'emplacement des commandes connues de son
parent (voir
<B>hash</B>

dans le paragraphe
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B></FONT>
plus bas).
<P>

Si le programme est un fichier commençant par
<B>#!</B>,

le reste de la première ligne indique un interpréteur pour ce programme.
Le shell se chargera d'exécuter cet interpréteur, si le système d'exploitation
ne gère pas lui-même ce format d'exécutable.
Les arguments de l'interpréteur consistent en un premier argument éventuel
fourni sur la première ligne du fichier à 
la suite du nom de l'interpréteur,
suivi du nom du programme, suivi des arguments de la commande
s'il y en a.
<A NAME="lbBU">&nbsp;</A>
<H2>ENVIRONNEMENT D'EXÉCUTION DES COMMANDES</H2>

Le shell fournit un <I>environnement d'exécution</I> consistant en l'ensemble
des éléments suivants :
<P>
<DL COMPACT>
<DT>&bull;<DD>
les fichiers ouverts hérités par le shell à son lancement, et modifiés par
les redirections de la commande interne <B>exec</B> ;
<DT>&bull;<DD>
le répertoire de travail configuré par <B>cd</B>, <B>pushd</B>, ou
<B>popd</B>, ou hérité par le shell  son démarrage ;
<DT>&bull;<DD>
le masque de création de fichier fixé par <B>umask</B> ou hérité du
père du shell ;
<DT>&bull;<DD>
la gestion des signaux configurée avec <B>trap</B> ;
<DT>&bull;<DD>
les paramètres du shemm fixés par des affectation de variables ou avec la
commande interne <B>set</B> ou hérité de l'environnement du père du shell ;
<DT>&bull;<DD>
les fonctions du shell définies lors de l'exécution ou héritées de
l'environnement du père du shell ;
<DT>&bull;<DD>
les options fournies au démarrage (par défaut ou sur la ligne de commandes)
ou par la commande interne <B>set</B> ;
<DT>&bull;<DD>
les options activées par la commande interne <B>shopt</B> ;
<DT>&bull;<DD>
les alias du shell définies par la commande <B>alias</B> ;
<DT>&bull;<DD>
les ID des divers processus, y compris ceux à l'arrière-plan, la valeur
de <B>$$</B>, et la valeur de <B>$PPID</B>.
</DL>
<P>

Lorsqu'une commande autre qu'une fonction interne ou une fonction du shell
doit être exécutée, elle est invoquée dans un environnement d'exécution
séparé constitué de ce qui suit.
Sauf indication contraire, les valeurs sont héritées de l'environnement
du shell.
<P>
<DL COMPACT>
<DT>&bull;<DD>
les fichier ouverts du shell, auxquels s'ajoutent les modification indiquées
par le redirections apportées à la commande ;
<DT>&bull;<DD>
le répertoire de travail en cours ;
<DT>&bull;<DD>
le masque de création de fichiers ;
<DT>&bull;<DD>
les variables du shell marquées pour l'exportation, ainsi que les variables
exportées spécialement pour la commande ;
<DT>&bull;<DD>
les signaux capturés par le shell reprennent le comportement hérité du père
du shell, et les signaux ignorés par le shell restent ignorés.
</DL>
<P>

Une commande invoquée dans un environnement distinct ne peut pas affecter
l'environnement d'exécution du shell.
<P>

Les substitutions de commandes et les commandes asynchrones sont invoquées dans
un environnement de sous-shell qui est une copie de celui du shell, sauf que
les signaux capturés par le shell reprennent le comportement qu'ils avaient au
lancement du shell. Les fonctions internes invoquées dans un pipeline sont
aussi exécutées dans un environnement de sous-shell. Les modifications apportées
à l'environnement d'un sous-shell n'affectent aucunement l'environnement
du shell.
<A NAME="lbBV">&nbsp;</A>
<H2>ENVIRONNEMENT</H2>

Quand un programme est invoqué, il reçoit un tableau de chaînes que l'on
appelle
<I>environnement</I>.

Il s'agit d'une liste de paires
<I>nom</I>-<I>valeur</I>, de la forme
<I>nom</I>=valeur.

<P>

Le shell permet de manipuler l'environnement de plusieurs façons.
Au démarrage, le shell analyse son propre environnement, et crée un
paramètre pour chaque nom trouvé, en le marquant
comme
<I>exportable</I>

vers les processus fils. Les commandes exécutées héritent de cet
environnement. Les commandes
<B>export</B>

et
<B>declare -x</B>

permettent d'ajouter ou de supprimer des paramètres ou des fonctions
de l'environnement. Si la valeur d'un paramètre de l'environnement est
modifiée, la nouvelle valeur devient une partie de l'environnement, et
elle remplace l'ancienne. L'environnement hérité par les commandes
exécutées est l'environnement initial du shell (dont les valeurs
peuvent être modifiées), 
moins les éléments supprimés par la commande
<B>unset</B>,

plus les éléments ajoutés 
par les commandes
<B>export</B>

et
<B>declare -x</B>.

<P>

L'environnement d'une
<I>commande simple</I>

ou d'une fonction peut être augmenté temporairement en la faisant
précéder d'une affectation de paramètre, comme nous l'avons vu au paragraphe
<FONT SIZE="-1"><B>PARAMÈTRES</B>.

</FONT>
Ces affectations ne concernent que l'environnement vu par cette
commande ou fonction.
<P>

Si l'option
<B>-k</B>

est utilisée (voir la commande interne
<B>set</B>

plus bas), alors
<I>toutes</I>

les affectations de paramètres sont placées dans l'environnement
d'une commande exécutée, pas seulement celles qui précèdent son nom.
<P>

Quand
<B>bash</B>

invoque une commande externe, la variable
<B>_</B>

contient le chemin d'accès complet à cette commande, et elle est
transmise dans l'environnement.
<A NAME="lbBW">&nbsp;</A>
<H2>CODE DE RETOUR</H2>

Au niveau du shell, une commande qui se termine avec un code
de retour nul est considérée comme réussie. Le zéro indique le
succès. Un code de retour non-nul indique un échec.
Quand une commande se termine à cause d'un signal fatal, <B>bash</B>
utilise la valeur 128+<B>signal</B> comme code de retour.
<P>

Si une commande n'est pas trouvée, le processus fils créé pour
l'exécuter renvoie la valeur 127. Si la commande est trouvée
mais pas exécutable, la valeur renvoyée est 126.
<P>

Si une commande échoue à cause d'une erreur survenue lors du développement ou
de la mise en place des redirections, le code de retour est supérieur à zéro.
<P>

Les fonctions interne renvoient zéro (<I>vrai</I>) si elles réussissent et une
valeur non nulle (<I>faux</I>) si une erreur se produit
durant leur exécution.
Toutes les fonctions internes renvoient 2 en cas d'erreur de syntaxe.
<P>

<B>Bash</B> lui-même renvoie le code de retour de la dernière commande
exécutée, à moins qu'une erreur de syntaxe ne se produise, auquel
cas il renvoie une valeur non-nulle. Voir également la commande
interne <B>exit</B> plus bas.
<A NAME="lbBX">&nbsp;</A>
<H2>SIGNAUX</H2>

Quand <B>bash</B> fonctionne de manière interactive, il ignore le signal
<FONT SIZE="-1"><B>SIGTERM</B>

</FONT>
(c'est pourquoi <B>kill 0</B> ne tue pas un shell interactif),
et le signal
<FONT SIZE="-1"><B>SIGINT</B>

</FONT>
est intercepté et géré (c'est pourquoi la commande interne <B>wait</B> n'est
pas interruptible). Dans tous les cas, <B>bash</B> ignore le signal
<FONT SIZE="-1"><B>SIGQUIT</B>.

</FONT>
Si le contrôle de jobs est disponible,
<B>bash</B>

ignore les signaux
<FONT SIZE="-1"><B>SIGTTIN</B>,

</FONT>
<FONT SIZE="-1"><B>SIGTTOU</B>,

</FONT>
et
<FONT SIZE="-1"><B>SIGTSTP</B>.

</FONT>
<P>

Les jobs synchrones lancés par <B>bash</B> reçoivent les valeurs des signaux
héritées par le shell de leur parent.  Quand le contrôle de job n'est pas
actif, les jobs en arrière-plan 
ignorent les signaux
<FONT SIZE="-1"><B>SIGINT</B>

</FONT>
et
<FONT SIZE="-1"><B>SIGQUIT</B>

</FONT>
également.
Les commandes exécutées en tant que résultat de la substitution de commandes
ignorent les signaux de contrôle de jobs émis par le clavier
<FONT SIZE="-1"><B>SIGTTIN</B>,

</FONT>
<FONT SIZE="-1"><B>SIGTTOU</B>,

</FONT>
et
<FONT SIZE="-1"><B>SIGTSTP</B>.

</FONT>
<P>

Par défaut, le shell se termine à la réception de
<FONT SIZE="-1"><B>SIGHUP</B>.

</FONT>
Avant de se terminer, il renvoie
<FONT SIZE="-1"><B>SIGHUP</B>

</FONT>
à tous les jobs en cours ou arrêtés.
Les jobs arrêtés reçoivent aussi
<FONT SIZE="-1"><B>SIGCONT</B>

</FONT>
pour s'assurer qu'il recevront bien le
<FONT SIZE="-1"><B>SIGHUP</B>.

</FONT>
Pour empêcher le shell d'envoyer ce signal à un job particulier,
il faut le retirer de la table des jobs
à l'aide de la commande interne
<B>disown</B>

(voir
<FONT SIZE="-1"><B>FONCTIONS INTERNES DU SHELL</B>

</FONT>
plus bas) ou le marquer comme exempté
de
<FONT SIZE="-1"><B>SIGHUP</B>

</FONT>
avec
<B>disown -h</B>.

<P>

Si l'option du shell
<B>huponexit</B>

a été activée avec la fonction
<B>shopt</B>,

<B>bash</B>

envoie un signal
<FONT SIZE="-1"><B>SIGHUP</B>

</FONT>
à tous les jobs lorsqu'un shell de login interactif se termine.
<P>

Lorsque <B>bash</B> reçoit un signal qu'il doit capturer, et qu'il attend la
fin d'une commande, le gestionnaire de signal ne sera pas exécuté avant que
la commande soit finie.
Lorsque <B>bash</B> attend la fin d'une commande asynchrone avec <B>wait</B>
la réception d'un signal capturé causera la fin immédiate de la
commande <B>wait</B> avec un code de retour supérieur à 128, à la suite 
de quoi le gestionnaire de signal sera exécuté.
<A NAME="lbBY">&nbsp;</A>
<H2>CONTRÔLE DES JOBS</H2>

Le
<I>contrôle des jobs</I>

permet d'arrêter (<I>suspend</I>) sélectivement l'exécution d'un
processus, et de la reprendre (<I>resume</I>) ultérieurement.
L'utilisateur bénéficie généralement de cette possibilité grâce à l'action
conjointe du pilote de terminal et de
<B>bash</B>.

<P>

L'interpréteur associe un
<I>job</I>

à chaque tube. Il maintient une table des jobs en cours d'exécution,
cette table pouvant être affichée avec la commande
<B>jobs</B>.

Quand
<B>bash</B>

lance un job de manière asynchrone (en
<I>arrière-plan</I>),

il affiche une ligne du genre :
<DL COMPACT><DT><DD>
<P>

[1] 25647
</DL>

<P>

Cette ligne indique que le job est associé au numéro 1, et que le PID du
dernier processus dans le tube est 25647.
Tous les processus dans un tube simple font partie du même job.
<B>Bash</B>

utilise la notion de
<I>job</I>

comme une abstraction pour aider à les contrôler.
<P>

Pour faciliter l'implémentation d'une interface utilisateur pour le contrôle
de job, le système introduit la notion d'ID de groupe de processus associés
à un terminal. Les membre de ce groupe de processus (ceux dont le GID est
égal au Process Group ID du terminal) reçoivent les signaux déclenchés par
le clavier, comme
<FONT SIZE="-1"><B>SIGINT</B>.

</FONT>
Ces processus sont dits en
<I>avant-plan</I>.

Les processus en
<I>arrière-plan</I>

sont ceux dont le Process-GID diffère de celui du terminal ; ils ne reçoivent
pas les signaux déclenchés par le clavier. Seuls les processus en avant-plan
peuvent lire depuis le terminal ou écrire dessus. Les processus en arrière-plan
qui tentent une lecture (ou une écriture) sur le terminal reçoivent les signaux
<FONT SIZE="-1"><B>SIGTTIN (SIGTTOU)</B>

</FONT>
émis par le pilote de périphérique du terminal, lesquels signaux suspendent
l'exécution du processus (sauf interception du signal).
<P>

Si le système d'exploitation sur lequel
<B>bash</B>

fonctionne permet le contrôle des jobs,
<B>bash</B>

vous y donne accès.
La frappe d'un caractère
<I>suspension</I>

(généralement
<B>^Z</B>,

Contrôle-Z) pendant l'exécution d'un processus
arrête celui-ci, et redonne la
main à 
<B>bash</B>.

La frappe d'un caractère
<I>suspension différée</I>

(généralement
<B>^Y</B>,

Contrôle-Y) arrêtera le processus au moment où il tentera de lire depuis le
terminal, et la main 
reviendra à 
<B>bash</B>.

Il est possible de manipuler ces jobs en utilisant la commande
<B>bg</B>

(background = arrière-plan) pour continuer l'exécution en arrière-plan, 
<B>fg</B>

(foreground) pour la reprendre en avant-plan,
ou encore la commande
<B>kill</B>

pour tuer le processus. Un <B>^Z</B> prend effet immédiatement,
et élimine
les sorties en attente.
<P>

Il y a plusieurs manières de faire référence à un job.
Le caractère
<B>%</B>

introduit un nom de job. Le job numéro
<I>n</I>

peut être noté
<B>%n</B>.

On peut également faire référence à un job en utilisant un préfixe
du nom utilise pour le lancer, ou une partie de la ligne de commande.
Par exemple,
<B>%ce</B>

se réfère à un job arrêté nomme
<B>ce</B>.

Si ce préfixe correspond à plusieurs jobs, 
<B>bash</B>

renverra une erreur. D'autre part,
<B>%?ce</B>,

fait référence à n'importe quel job contenant la chaîne
<B>ce</B>

dans sa ligne de commande. Si la sous-chaîne correspond à plusieurs jobs,
<B>bash</B>

renverra une erreur. Les symboles
<B>%%</B>

et
<B>%+</B>

référencent le
<I>job courant</I>

du shell, c'est à dire le dernier job arrêté alors qu'il se
trouvait en avant-plan.
Le
<I>job précédent</I>

peut être mentionné en utilisant
<B>%-</B>.

Dans les affichages se rapportant aux jobs (par exemple ceux de la commande
<B>jobs</B>

le job courant est toujours indiqué par un
<B>+</B>,

et le job précédent avec un
<B>-</B>.

<P>

Il suffit de nommer un job pour le ramener
en avant-plan :
<B>%1</B>

est synonyme de
<B>``fg %1''</B>,
et ramène le job 1 depuis l'arrière-plan vers l'avant-plan.
De même,
<B>``%1 &amp;''</B>

relance le job 1, mais en arrière-plan cette fois, de manière équivalente à
<B>``bg %1''</B>.
<P>

Le shell est immédiatement prévenu lorsqu'un job change d'état.
Normalement
<B>bash</B>

attend d'être prêt à afficher son symbole d'accueil avant de fournir
un rapport sur les changements dans les statut des jobs, afin de ne
pas perturber les autres affichages. Si l'option
<B>-b</B>

de la commande interne
<B>set </B>

est
active
<B>bash</B>

affichera les modifications immédiatement.
<P>

Si vous essayez de quitter
<B>bash</B>

avec des jobs suspendus, le shell affichera un avertissement. La commande
<B>jobs</B>

permet de vérifier leurs états. Une fois cette commande invoquée,
ou si vous essayez
à nouveau de quitter le shell immédiatement, il n'y aura plus d'avertissement,
et les jobs suspendus seront définitivement terminés.
<A NAME="lbBZ">&nbsp;</A>
<H2>SYMBOLE D'ACCUEIL (PROMPT)</H2>

Quand il est exécuté de manière interactive,
<B>bash</B>

affiche le symbole d'accueil principal
<FONT SIZE="-1"><B>PS1</B>

</FONT>
dès qu'il est prêt à lire une commande, et le symbole d'accueil secondaire
<FONT SIZE="-1"><B>PS2</B>

</FONT>
quand il a besoin de plus de données pour exécuter une commande.
<B>Bash</B>

permet de personnaliser ces chaînes d'accueil, avec des séquences d'échappement
ayant les significations suivantes :
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>\a</B>

<DD>
le caractère d'alarme ASCII 07
<DT><B>\d</B>

<DD>
la date au format &quot;Jour_de_la_semaine Mois Quantième&quot; (ex : &quot;Tue May 26&quot;)
<DT><B>\e</B>

<DD>
le caractère d'échappement ASCII 033
<DT><B>\h</B>

<DD>
le nom d'hôte de la machine, juqu'au premier point `.'
<DT><B>\H</B>

<DD>
le nom d'hôte complet de la machine
<DT><B>\n</B>

<DD>
un saut de ligne
<DT><B>\r</B>

<DD>
un retour-chariot
<DT><B>\s</B>

<DD>
le nom du shell, c'est à dire le nom de base de
<B>$0</B>

(la portion suivant le dernier slash)
<DT><B>\t</B>

<DD>
l'heure actuelle au format HH:MM:SS sur 24 heures
<DT><B>\T</B>

<DD>
l'heure actuelle au format HH:MM:SS sur 12 heures
<DT><B>\@</B>

<DD>
l'heure actuelle sur 12 heures au format HH:MM am/pm
<DT><B>\u</B>

<DD>
le nom de l'utilisateur
<DT><B>\v</B>

<DD>
la version de <B>bash (par exemple 2.04)
<DT>\V</B>

<DD>
le numéro de version complet de <B>bash par exemple (2.04.0)
<DT>\w</B>

<DD>
le répertoire de travail en cours
<DT><B>\W</B>

<DD>
le nom de base du répertoire de travail en cours
<DT><B>\!</B>

<DD>
le numéro d'historique de la commande
<DT><B>\#</B>

<DD>
le numéro de la commande
<DT><B>\$</B>

<DD>
<B># </B>

si l'UID effectif est 0,
<B>$</B>

sinon
<DT><B>\nnn</B>

<DD>
le caractère de code octal <B>nnn</B>
<DT><B>\\</B>

<DD>
le caractère antislash
<DT><B>\[</B>

<DD>
débute une série de caractères non-imprimables, qui permettent
d'inclure des séquences de contrôle de terminal dans une chaîne d'accueil
<DT><B>\]</B>

<DD>
fin d'une série de caractères non-imprimables

</DL>
</DL>

<P>

Le numéro de commande, et le numéro d'historique sont généralement
différents : le numéro d'historique d'une commande correspond à sa
position dans la liste d'historique qui peut contenir des commandes
relues depuis cette liste (voir le paragraphe
<FONT SIZE="-1"><B>HISTORIQUE</B>

</FONT>
plus bas), alors que le numéro de commande est simplement une position
dans la séquence de commandes exécutées depuis le début de la session
shell actuelle. Après que la chaîne d'invite ait été décodée, elle est
soumise à l'expansion des paramètres, substitution de commandes, évaluation
arithmétique et découpage des mots, sous condition de l'option shell
<B>promptvars</B>

(voir la description de
<B>shopt</B>

au paragraphe
<FONT SIZE="-1"><B>FONCTIONS INTERNES DU SHELL</B>

</FONT>
plus bas).
<A NAME="lbCA">&nbsp;</A>
<H2>BIBLIOTHÈQUE READLINE</H2>

Il s'agit de la bibliothèque qui gère la saisie lors des sessions
interactives du shell, à moins que l'option
<B>-nolineediting</B>

n'ait été choisie. Par défaut les commandes d'édition de ligne sont similaires
à celles d'emacs. Il est également possible de disposer d'une interface
d'édition du style vi.
Pour arrêter l'édition de ligne, utiliser l'option
<B>+o emacs</B>

ou
<B>+o vi</B>

de la commande
<B>set</B>

(voir
<FONT SIZE="-1"><B>FONCTIONS INTERNES DU SHELL</B>

</FONT>
plus bas).
<A NAME="lbCB">&nbsp;</A>
<H3>Notation Readline</H3>

<P>

Dans ce paragraphe on utilisera la notation &quot;à la emacs&quot; pour indiquer
les séquences de touches. Les touches Contrôle sont notées
C-<I>touche</I>, par exemple C-n signifie Contrôle-N.  De même, les touches
<I>Méta</I>

sont notées par M-<I>touche</I>, ainsi M-x signifie Méta-X.
(Sur les claviers sans touches
<I>Méta</I>,

M-<I>x</I> signifie ESC <I>x</I> (sur les claviers français ESC est noté
Échappement), autrement dit presser la touche Échappement puis la touche
<I>x</I>.

On dit alors qu'ESC est le <I>préfixe méta</I>.
La séquence M-C-<I>x</I> signifie ESC-Contrôle-<I>x</I>,
ou encore Presser la touche Échappement puis maintenez la touche Contrôle
enfoncée tout
en pressant la touche
<I>x</I>.

<P>

Les commandes readline peuvent recevoir des
<I>arguments</I>

numériques, qui fonctionnent en règle générale comme compteurs de répétitions.
Parfois, néanmoins le signe de l'argument est significatif.
L'utilisation d'un argument négatif pour une commande agissant dans un sens 
donné (par ex. <B>kill-line</B>) fait agir la commande en
sens inverse.
Les commandes ayant un comportement différent sont indiqués
plus bas.
<P>

Lorsqu'une commande est indiquée comme <I>détruisant</I> du texte, le texte
effacé est en fait disponible pour une récupération ultérieure.
Il est sauvé dans un tampon circulaire. Les suppressions successives
accumulent les textes en un seul bloc qui peut être récupéré en une fois.
Les commandes non destructrices séparent les blocs de textes dans
le buffer
circulaire.
<A NAME="lbCC">&nbsp;</A>
<H3>Initialisation de Readline</H3>

<P>

L'affectation par défaut des touches peut être modifiée dans un fichier
d'initialisation (<I>inputrc</I>).
Le nom de ce fichier est lu dans la variable shell
<FONT SIZE="-1"><B>INPUTRC</B>.

</FONT>
Si la variable n'existe pas, le nom par défaut est
<I>~/.inputrc</I>.

Quand un programme utilisant la bibliothèque readline démarre, les fichiers
d'initialisation sont lus, et les affectations de touches et de variables
sont mises en place.
Il n'y a que peu d' constructions possibles dans les
fichiers d'initialisation de Readline.
Les lignes blanches sont ignorées.
Les lignes commençant par <B>#</B> sont des commentaires.
Les lignes commençant par <B>$</B> indiquent des constructions conditionnelles.
Les autres lignes sont des affectations de touches ou de variables.
<P>

Les affectations par défaut des touches peuvent être modifiés par un fichier
<I>inputrc </I>

d'initialisation.
D'autres programmes qui utilisent cette bibliothèque peuvent ajouter
leurs propres affectations de touches.
<P>

Par exemple, en plaçant
<DL COMPACT><DT><DD>
<P>

M-Control-u: universal-argument
</DL>

ou
<DL COMPACT><DT><DD>
C-Meta-u: universal-argument
</DL>

dans le fichier
<I>~/.inputrc</I>,

on affectera à la séquence de touche M-C-u la commande readline
<I>universal-argument</I>.

<P>

Les caractères symboliques suivants sont acceptés :
<I>RUBOUT</I>,

<I>DEL</I>,

<I>ESC</I>,

<I>LFD</I>,

<I>NEWLINE</I>,

<I>RET</I>,

<I>RETURN</I>,

<I>SPC</I>,

<I>SPACE</I>,

et
<I>TAB</I>.

En plus des noms de commandes, readline permet d'affecter à une touche une 
chaîne de caractères qui sera insérée lors de la pression (<I>macro</I>).
<A NAME="lbCD">&nbsp;</A>
<H3>Affectation des touches de Readline</H3>

<P>

La syntaxe des affectations de touches dans le fichier
<I>~/.inputrc</I>

est simple.  Les seules choses nécessaires sont le nom d'une commande,
ou le texte d'une macro, et la séquence de touches à laquelle il faut
l'affecter.  Les touches peuvent être indiquées de deux manières :
sous forme de nom symbolique, éventuellement précédé de <I>Meta-</I> ou
<I>Control-</I>, ou sous forme de séquence de touches.
Avec la forme <B>touche</B>:<I>nom_de_fonction</I> ou <I>macro</I>,
<I>touche</I>

est le nom de la séquence de touches épelée en Anglais. Par exemple :
<P>
<DL COMPACT><DT><DD>
Control-u: universal-argument
<BR>

Meta-Rubout: backward-kill-word
<BR>

Control-o: &quot;&gt; sortie&quot;
</DL>

<P>

Dans ces exemples,
<I>C-u</I>

est assigné à la fonction
<B>universal-argument</B>,

<I>M-DEL</I>

à la fonction
<B>backward-kill-word</B>,

et
<I>C-o</I>

est affecté à la macro exprimée dans la partie gauche (c'est à dire insérera
<I>&gt; sortie</I>

sur la ligne).
<P>

Avec la seconde forme, <B>&quot;touches&quot;</B>:<I>nom_de_fonction</I> ou <I>macro</I>,
<B>touches</B>

n'est plus un nom symbolique, mais décrit
une séquence complète de touches
entre guillemets. 
Certaines séquences d'échappement 
dans le style GNU Emacs peuvent
être utilisée, 
comme dans l'exemple suivant :
<P>
<DL COMPACT><DT><DD>
&quot;\C-u&quot;: universal-argument
<BR>

&quot;\C-x\C-r&quot;: re-read-init-file
<BR>

&quot;\e[11~&quot;: &quot;Touche Fonction 1&quot;
</DL>

<P>

Dans cet exemple, 
<I>C-u</I>

est à nouveau assigné à la fonction
<B>universal-argument</B>,

<I>C-x C-r</I>

à la fonction
<B>re-read-init-file</B>,

et
<I>ESC [ 1 1 ~</I>

insérera le texte
<B>Touche Fonction 1</B>.

L'ensemble complet des séquences d'échappement est le suivant :
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>\C-</B>

<DD>
préfixe Contrôle
<DT><B>\M-</B>

<DD>
préfixe Méta
<DT><B>\e</B>

<DD>
caractère d'échappement
<DT><B>\\</B>

<DD>
backslash
<DT><B>\</B>

<DD>
un guillemet &quot; littéral
<DT><B>\'</B>

<DD>
une apostrophe ' littéral
</DL>
</DL>


<P>

En plus des séquences dans le style Gnu Emacs, un second jeu de
séquences d'échappement est disponible
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>\a</B>

<DD>
alerte (sonnerie)
<DT><B>\b</B>

<DD>
backspace
<DT><B>\d</B>

<DD>
effacement
<DT><B>\f</B>

<DD>
saut de page
<DT><B>\n</B>

<DD>
saut de ligne
<DT><B>\r</B>

<DD>
retour-chariot
<DT><B>\t</B>

<DD>
tabulation horizontale
<DT><B>\v</B>

<DD>
tabulation verticale
<DT><B>\</B><I>nnn</I>

<DD>
le caractère de code ASCII <I>nnn</I> en octal
(de un à trois chiffres)
<DT><B>\x</B><I>nnn</I>

<DD>
le caractère de code ASCII <I>nnn</I> en hexadécimal
(un à trois chiffres)
</DL>
</DL>


<P>

Lorsque l'on saisit le texte d'une macro, il faut utiliser des apostrophes
ou des guillemets pour indiquer la définition de la macro. Les textes
non protégés sont considérés comme des noms de fonctions.
Le backslash protégera n'importe quel caractère dans la
définition d'une macro,
y compris &quot; et '.
<P>

<B>Bash</B>

permet d'afficher ou de modifier les affectations des touches avec la commande
interne
<B>bind</B>.

On peut changer de mode d'édition durant une session interactive en utilisant
l'option
<B>-o</B>

de la commande interne
<B>set</B>

(voir le paragraphe
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas).
<A NAME="lbCE">&nbsp;</A>
<H3>Variables de Readline</H3>

<P>

Readline dispose de variables permettant de personnaliser encore plus son
comportement. Une variable peut être configurée dans le fichier
<I>inputrc</I>

avec une déclaration de la forme
<DL COMPACT><DT><DD>
<P>

<B>set</B> <I>nom_de_variable</I> <I>valeur</I>
</DL>

<P>

Sauf contre-indication, les variables de readline prennent les
valeurs
<B>On</B>

ou
<B>Off</B>.

Les variables, et leurs valeurs par défaut, sont :
<P>


<DL COMPACT>
<DT><B>bell-style (audible)</B>

<DD>
Cette variable commande readline lorsqu'il faut déclencher le signal sonore du
terminal. Si cette variable contient la valeur <B>none</B>, readline n'utilise
pas de signal, si elle contient <B>visible</B>, on utilise un avertisseur visuel,
si elle contient <B>audible</B>, readline essaie le signal sonore du terminal.
<DT><B>comment-begin (``#'')</B>

<DD>
Cette chaîne est insérée quand la commande
<B>readline</B>

<B>insert-comment</B>

est exécutée.
Elle est affectée à
<B>M-#</B>

en mode emacs, et
<B>#</B>

en mode vi.
<DT><B>completion-ignore-case (Off)</B>

<DD>
Sur <B>On</B>, Readline effectue les comparaisons et complétions de noms de
fichiers en différenciant les majuscules et minuscules.
<DT><B>completion-query-items (100)</B>

<DD>
Lors de la complétion de commandes, si le nombre de possibilités est supérieur à
cette valeur, on demandera confirmation à l'utilisateur avant
d'afficher la liste des possibilités. Le nombre de complétions possibles est
déterminé par la commande <B>possible-completions</B>. Il peut s'agir de
n'importe quelle valeur entière
supérieure ou égale
à
zéro
<DT><B>convert-meta (On)</B>

<DD>
Si cette variable contient la valeur <B>On</B>, readline transformera en
séquences ASCII les caractères ayant leur huitième bit à 1. Il supprimera ce
huitième bit, et insérera comme préfixe le caractère d'échappement (en utilisant
ce caractère d'échappement comme <I>préfixe méta</I>).
<DT><B>disable-completion (Off)</B>

<DD>
Si cette variable contient <B>On</B>, Readline désactivera la complétion des mots.
Les caractères de complétion seront insérés sur la ligne comme s'ils avaient été
associé à <B>self-insert</B>.
<DT><B>editing-mode (emacs)</B>

<DD>
Cette variable indique si readline doit démarrer avec des affectations de touches
similaires à <I>emacs</I> ou à <I>vi</I>.
<B>editing-mode</B>

peut prendre les valeurs
<B>emacs</B>

ou
<B>vi</B>.

<DT><B>enable-keypad (Off)</B>

<DD>
Sur <B>On</B>, Readline essayera d'activer le clavier de l'application
lorsqu'elle sera invoquée. Sur certains systèmes, cela est nécessaire
pour utiliser les touches flèchées.
<DT><B>expand-tilde (Off)</B>

<DD>
Si cette variable contient la valeur <B>on</B>, le développement du tilde est
effectué lorsque readline tente une complétion de commandes.
<DT><B>horizontal-scroll-mode (Off)</B>

<DD>
Si cette variable contient la valeur <B>On</B>, readline utilisera une seule
ligne d'affichage, et la fera défiler horizontalement si elle devient plus
longue que la largeur de l'écran, plutôt que de basculer sur une nouvelle ligne.
<DT><B>input-meta (Off)</B>

<DD>
Si cette variable contient la valeur <B>On</B>, readline acceptera des saisies sur
huit bits (autrement dit il ne supprimera pas le huitième bit), quelque soit 
le terminal utilisé. Le nom
<B>meta-flag</B>

est un synonyme pour cette variable.
<DT><B>isearch-terminators (``C-[C-J'')</B>

<DD>
La chaîne de caractères qui doivent terminer une recherche incrémentale
sans que le caractère ne soit exécuté comme une commande.
Si cette variable n'a pas de valeur, les caractères
<I>ESC</I> et <I>C-J</I> termineront une recherche incrémentale.
<DT><B>keymap (emacs)</B>

<DD>
Configure l'affectation des touches. Les jeux d'affectations disponibles sont
<I>emacs, emacs-standard, emacs-meta, emacs-ctlx, vi, 
vi-command</I>, et
<I>vi-insert</I>.

<I>vi</I> est équivalent à <I>vi-command</I>; <I>emacs</I> est équivalent à
<I>emacs-standard</I>.  La valeur par défaut est
<I>emacs</I>;

notez que la configuration de la variable
<B>editing-mode</B>

modifie aussi l'affectation par défaut.
<DT><B>mark-directories (On)</B>

<DD>
Sur <B>On</B>, les noms de répertoires sont complétés par
un slash.
<DT><B>mark-modified-lines (Off)</B>

<DD>
Sur <B>On</B>, les lignes d'historique qui ont été modifiées seront précédées
à l'affichage d'un astérisque (<B>*</B>).
<DT><B>output-meta (Off)</B>

<DD>
Si cette variable contient la valeur <B>On</B>, readline affichera directement les
caractères ayant leur huitième bit à 1, plutôt que d'utiliser une séquence
d'échappement avec le préfixe méta.
<DT><B>print-completions-horizontally (Off)</B>

<DD>
Sur <B>On</B>, Readline affichera les possibilités de complétions triés
horizontalement dans l'ordre alphabétique plutôt que verticalement.
<DT><B>show-all-if-ambiguous (Off)</B>

<DD>
Cette variable agit sur la complétion des commandes. Lorsqu'elle contient la
valeur
<B>on</B>,

toutes les complétions possibles sont affichées immédiatement plutôt que de
déclencher l'avertisseur sonore.
<DT><B>visible-stats (Off)</B>

<DD>
Sur <B>On</B>, un caractère indiquant le type de fichier, comme fourni par
l'appel-système <I><A HREF="/cgi-bin/man/man2html?2+stat">stat</A></I>(2) sera ajouté aux noms de fichiers lors de
l'affichage des complétions possibles.

</DL>
<A NAME="lbCF">&nbsp;</A>
<H3>Constructions conditionnelles de Readine</H3>

<P>

Readline propose un mécanisme inspiré des possibilités de compilation
conditionnelle en C, qui permet d'effectuer certaines assignations de
variables, ou affectations de touches en fonction du résultat d'un test.
Il y a quatre directives utilisables.
<DL COMPACT>
<DT><B>$if</B><DD>
La structure
<B>$if</B>

permet d'affecter les touches en fonction du mode d'édition, du terminal
de saisie, ou de l'application qui utilise la bibliothèque readline. Le
texte du test se trouve à la
suite du <B>$if</B>, jusqu'à la fin de la ligne.
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>mode</B><DD>
La forme <B>mode=</B> de la structure <B>$if</B> permet de vérifier si
readline est en mode emacs ou en mode vi.
Ceci peut être utilisé conjointement à la
commande <B>set keymap</B>, par exemple pour ne configurer les jeux de
touches <I>emacs-standard</I> et <I>emacs-ctlx</I> que
si readline démarre en mode emacs.
<DT><B>term</B><DD>
La forme <B>term=</B> peut être utilisée pour ajouter des affectations de
touches spécifiques au terminal, par exemple sur des touches de fonction.
Le mot à droite du signe
<B>=</B>

est comparé au nom complet du terminal, et à la portion du nom qui précède un
éventuel signe <B>-</B>. Ceci permet, par exemple, de faire correspondre le mot
<I>sun</I>

aussi bien au terminal
<I>sun</I>

qu'au
terminal
<I>sun-cmd</I>.

<DT><B>application</B><DD>
La forme <B>application</B> permet d'inclure des configurations spécifiques
à l'application. Chaque programme utilisant la bibliothèque readline
configure un <I>nom d'application</I>, et un fichier d'initialisation peut
dépendre de ce nom.
Ceci est utile pour des affecter des touches intéressant un programme
spécifique. Ainsi, les commandes suivantes ajoutent une séquence de touches
protégeant par des guillemets le mot courant ou le mot précédent, sous Bash :
<P>
<DL COMPACT><DT><DD>
<PRE>
<B>$if</B> Bash
# Protéger le mot actuel ou le précédent
&quot;\C-xq&quot;: &quot;\eb\&quot;\ef\&quot;&quot;
<B>$endif</B>
</PRE>

</DL>

</DL>
</DL>

<DT><B>$endif</B><DD>
Cette commande, comme on l'a vu dans l'exemple ci-dessus, termine une commande
<B>$if</B>.
<DT><B>$else</B><DD>
Permet d'ajouter des commandes qui seront exécutées si un <B>$if</B>
échoue.
</DL>
<P>

<DL COMPACT>
<DT><B>$include</B><DD>
Cette directive prend un simple nom de fichier en argument et y lit les 
commandes et les affectations. Par exemple, la directive suivante lit 
le fichier <I>/etc/inputrc</I>:
<P>
<DL COMPACT><DT><DD>
<PRE>
<B>$include</B>  <I>/etc/inputrc</I>
</PRE>

</DL>

</DL>
<A NAME="lbCG">&nbsp;</A>
<H3>Recherche</H3>

<P>

Readline propose des commandes de recherche au sein de l'historique de commandes
(voir
<FONT SIZE="-1"><B>HISTORIQUE</B>

</FONT>
plus bas) des lignes contenant une chaîne donnée.
Il y a deux modes de recherche :
<I>incrémental</I>

et 
<I>non-incrémental</I>.

<P>

Les recherches incrémentales commencent avant même que l'utilisateur ait
terminé de saisir la chaîne recherchée.
À chaque caractère saisi, Readline affiche l'entrée suivante de l'historique
qui corresponde à la chaîne déjà entrée.
Une recherche incrémentale nécessite seulement le nombre de caractères
indispensable pour retrouver l'entrée d'historique désirée.
Les caractères se trouvant dans la variable <I>isearch-terminators</I>
servent à terminer une recherche incrémentale.
Si cette variable n'a pas de valeur, les caractères Escape et Contrôle-J
terminent une recherche incrémentale.
Contrôle-G permet d'interrompre une recherche incrémentale de reprendre
la ligne originale.
Lorsque la recherche est finie, l'entrée d'historique contenant la chaîne
désirée devient la ligne en cours.
Poue trouver une autre entrée d'historique correspondant aussi, il faut
taper Contrôle-S ou Contrôle-R.
Cela recherchera en avant ou en arrière l'entrée d'historique suivante
qui corresponde à la chaîne saisie jusque là.
Toute séquence de touche affectée à une commande Readline terminera
la recherche et exécutera la commande.
Par exemple, un <I>newline</I> terminera la recherche et validera la
ligne, ce qui exécute la commande de la ligne d'historique.
<P>

Les recherches non-incrémentales lisent la chaîne désirée en entier avant 
de démarrer la recherche de correspondance dans la liste d'historique. La
chaîne peut être saisie par l'utilisateur ou se trouver sur la ligne en cours.
<A NAME="lbCH">&nbsp;</A>
<H3>Noms des commandes Readline</H3>

<P>

Voici une liste des noms de commandes, ainsi que les séquences de
touches auxquelles elles sont attribuées par défaut.
Les commandes sans séquence indiquée n'ont pas d'affectation par défaut.
<A NAME="lbCI">&nbsp;</A>
<H3>Commandes de déplacement</H3>

<P>


<DL COMPACT>
<DT><B>beginning-of-line (C-a)</B>

<DD>
Saut au début de la ligne en cours.
<DT><B>end-of-line (C-e)</B>

<DD>
Saut à la fin de la ligne.
<DT><B>forward-char (C-f)</B>

<DD>
Avancer d'un caractère.
<DT><B>backward-char (C-b)</B>

<DD>
Reculer d'un caractère.
<DT><B>forward-word (M-f)</B>

<DD>
Avancer jusqu'à la fin du mot suivant. Les mots sont composés de caractères
alphanumériques (lettres et chiffres).
<DT><B>backward-word (M-b)</B>

<DD>
Reculer jusqu'au début du mot courant, ou du précédent. Les mots sont composés
de caractères alphanumériques (lettres et chiffres).
<DT><B>clear-screen (C-l)</B>

<DD>
Effacer l'écran, en laissant la ligne courante en haut de l'écran. S'il y a un
argument, rafraîchir la ligne en cours sans effacer
l'écran.
<DT><B>redraw-current-line</B>

<DD>
Rafraîchir la ligne en cours. Par défaut pas d'affectation de touche.

</DL>
<A NAME="lbCJ">&nbsp;</A>
<H3>Commandes de manipulation de l'historique</H3>

<P>


<DL COMPACT>
<DT><B>accept-line (Retour-Chariot)</B>

<DD>
Valider la ligne, sans se soucier de l'emplacement du curseur. Si la ligne n'est
pas vide, l'ajouter à la liste d'historique, sous contrôle de la variable
<FONT SIZE="-1"><B>HISTCONTROL</B>.

</FONT>
Si cette ligne est une modification d'une ligne de l'historique,
restaurer cette dernière.
<DT><B>previous-history (C-p)</B>

<DD>
Récupérer la commande précédente de la liste 
d'historique.
<DT><B>next-history (C-n)</B>

<DD>
Récupérer la commande suivante dans la liste
d'historique.
<DT><B>beginning-of-history (M-&lt;)</B>

<DD>
Récupérer la première ligne de l'historique.
<DT><B>end-of-history (M-&gt;)</B>

<DD>
Retourner à la fin de l'historique, c'est à dire à la ligne en cours
d'édition.
<DT><B>reverse-search-history (C-r)</B>

<DD>
Rechercher en arrière dans l'historique, en remontant. C'est une recherche
incrémentale.
<DT><B>forward-search-history (C-s)</B>

<DD>
Rechercher en avant dans l'historique, en descendant. C'est une recherche
incrémentale.
<DT><B>non-incremental-reverse-search-history (M-p)</B>

<DD>
Rechercher une chaîne en arrière dans l'historique, en remontant depuis
la ligne actuelle, utiliser une recherche non-incrémentale.
<DT><B>non-incremental-forward-search-history (M-n)</B>

<DD>
Rechercher une chaîne en avant dans l'historique,
utiliser une recherche non-incrémentale.
<DT><B>history-search-forward</B>

<DD>
Rechercher en avant dans l'historique la chaîne comprise entre le début de
la ligne actuelle, et la position du curseur. Par défaut cette commande
n'est affectée à aucune touche.
Cette une recherche non-incrémentale.
<DT><B>history-search-backward</B>

<DD>
Rechercher en arrière dans l'historique la chaîne comprise entre le début 
de la ligne actuelle, et la position du curseur.
Cette une recherche non-incrémentale.
<DT><B>yank-nth-arg (M-C-y)</B>

<DD>
Insérer, à l'emplacement du curseur, le premier argument de la commande
précédente. Généralement il s'agit du second mot de la ligne précédente.
Avec un argument
<I>n</I>,

insérer le <I>n</I>ième mot de la commande précédente (les mots sont numérotés
à partir de 0). Un argument négatif insère le <I>n</I>ième mot en partant de
la fin de la commande précédente.
<DT><B>yank-last-arg (M-., M-_)</B>

<DD>
Insérer à la position du curseur le dernier argument de la commande précédente
(le dernier mot de la ligne précédente). Avec un argument, se comporte
exactement comme <B>yank-nth-arg</B>.
Les appels successifs à <B>yank-last-arg</B> reviennent en arrière dans 
l'historique en insérant le dernier argument de chaque ligne à chaque fois.
<DT><B>shell-expand-line (M-C-e)</B>

<DD>
Développer, comme le fait le shell, la ligne en cours. Ceci inclut le
remplacement des alias et des directives d'historique, aussi bien que
l'ensemble des expansions effectuées par le shell. Voir
<FONT SIZE="-1"><B>EXPANSION DE L'HISTORIQUE</B>

</FONT>
plus bas, pour une description détaillée.
<DT><B>history-expand-line (M-^)</B>

<DD>
Effectuer l'expansion d'historique sur la ligne en cours.
Voir le paragraphe
<FONT SIZE="-1"><B>EXPANSION DE L'HISTORIQUE</B>

</FONT>
plus bas, pour une description détaillée.
<DT><B>magic-space</B>

<DD>
Effectuer l'expansion de l'historique sur la ligne en cours et insérer une
espace. Voir
<FONT SIZE="-1"><B>EXPANSION DE L'HISTORIQUE</B>

</FONT>
plus bas, pour une description détaillée.
<DT><B>alias-expand-line</B>

<DD>
Effectuer l'expansion des alias sur la ligne en cours.
Voir
<FONT SIZE="-1"><B>ALIAS</B>

</FONT>
plus bas pour une description des expansions d'alias.
<DT><B>history-and-alias-expand-line</B>

<DD>
Effectuer l'expansion de l'historique et des alias sur la ligne en cours.
<DT><B>insert-last-argument (M-., M-_)</B>

<DD>
un synonyme de <B>yank-last-arg</B>.
<DT><B>operate-and-get-next (C-o)</B>

<DD>
Valider la ligne en cours, et récupérer la ligne suivante de
l'historique pour l'édition.
Tout argument est ignoré.

</DL>
<A NAME="lbCK">&nbsp;</A>
<H3>Commande d'édition de texte</H3>

<P>


<DL COMPACT>
<DT><B>delete-char (C-d)</B>

<DD>
Effacer le caractère sous le curseur. Si le curseur est au début de la
ligne, si celle-ci est vide, et si le dernier caractère frappé n'était
pas <B>delete-char</B>, alors
la valeur renvoyée est
<FONT SIZE="-1"><B>EOF</B>.

</FONT>
<DT><B>backward-delete-char (Rubout)</B>

<DD>
Effacer le caractère derrière le curseur. Lorsque un argument est fourni,
le texte effacé est sauvegardé dans le buffer circulaire.
<DT><B>forward-backward-delete-char</B>

<DD>
Effacer le caractère sous le curseur, sauf s'il est en fin de ligne,
auquel cas le caractère derrière le curseur est effacé.
Par défaut cette action n'est associée à aucune touche.
<DT><B>quoted-insert (C-q, C-v)</B>

<DD>
Ajouter littéralement sur la ligne le caractère frappé suivant. Ceci permet
d'insérer des caractères comme <B>C-q</B>, par exemple.
<DT><B>tab-insert (C-v TAB)</B>

<DD>
Insérer un caractère de tabulation.
<DT><B>self-insert (a,&nbsp;b,&nbsp;A,&nbsp;1,&nbsp;!,&nbsp;...)</B>

<DD>
Insérer le caractère mentionné.
<DT><B>transpose-chars (C-t)</B>

<DD>
Échanger les caractères se trouvant devant et sous le curseur. Le curseur
est avancé d'un caractère. À la fin d'une ligne, les caractères échangés
sont les deux précédents. Les arguments négatifs ne sont pas acceptés.
<DT><B>transpose-words (M-t)</B>

<DD>
Échanger le mot où se trouve le curseur et le mot précédent, puis avancer le
curseur après ce mot.
<DT><B>upcase-word (M-u)</B>

<DD>
Transformer le mot en cours (ou le suivant) en majuscules. Avec un argument
négatif, agir sur le mot précédent mais ne pas déplacer le curseur.
<DT><B>downcase-word (M-l)</B>

<DD>
Transformer le mot en cours (ou le suivant) en minuscules. Avec un argument
négatif, agir sur le mot précédent mais ne pas déplacer le curseur.
<DT><B>capitalize-word (M-c)</B>

<DD>
Passer en majuscule l'initiale du mot en cours (ou du suivant). Avec un argument
négatif, agir sur le mot précédent mais ne pas déplacer le curseur.

</DL>
<A NAME="lbCL">&nbsp;</A>
<H3>Effacement et récupération</H3>

<P>


<DL COMPACT>
<DT><B>kill-line (C-k)</B>

<DD>
Effacer le texte depuis l'emplacement du curseur jusqu'à la fin de la ligne.
<DT><B>backward-kill-line (C-x C-Rubout)</B>

<DD>
Effacer en arrière jusqu'au début de ligne.
<DT><B>unix-line-discard (C-u)</B>

<DD>
Effacer le texte entre le début de la ligne et l'emplacement du curseur.
Le texte est sauvegardé dans le buffer circulaire.
<DT><B>kill-whole-line</B>

<DD>
Effacer toute la ligne sans tenir compte de la
position du curseur.
<DT><B>kill-word  (M-d)</B>

<DD>
Effacer le texte entre l'emplacement du curseur et la fin du mot en cours,
ou jusqu'à la fin du mot suivant si le curseur est entre deux mots.
Les séparations de mots sont les mêmes que celles de <B>forward-word</B>.
<DT><B>backward-kill-word (M-Rubout)</B>

<DD>
Effacer le mot sous le curseur
Les séparations de mots sont les mêmes que celles de <B>backward-word</B>.
<DT><B>unix-word-rubout (C-w)</B>

<DD>
Effacer le mot derrière le curseur, en utilisant l'espace blanc comme limite
de mot. Cette limite est différente de celle de <B>backward-kill-word</B>.
<DT><B>delete-horizontal-space (M-\)</B>

<DD>
Effacer tous les espaces blancs et les tabulations autour du curseur.
<DT><B>kill-region</B>

<DD>
Détruire le texte entre le curseur et la <I>marque</I> (position du curseur
sauvegardée précédemment). On appelle ceci une <I>région</I>.
<DT><B>copy-region-as-kill</B>

<DD>
Copier le texte de la région vers le buffer circulaire.
<DT><B>copy-backward-word</B>

<DD>
Copier le mot précédant le curseur dans le buffer circulaire.
Les séparations de mots sont les mêmes que celles de <B>backward-word</B>.
<DT><B>copy-forward-word</B>

<DD>
Copier le mot suivant le curseur dans le buffer circulaire.
Les séparations de mots sont les mêmes que celles de <B>backward-word</B>.
<DT><B>yank (C-y)</B>

<DD>
Récupérer le texte au sommet du tampon circulaire.
<DT><B>yank-pop (M-y)</B>

<DD>
Exécuter une rotation du tampon circulaire, et récupérer le nouveau texte situé 
à son sommet. Ceci ne fonctionne qu'après
<B>yank</B> ou

<B>yank-pop</B>.


</DL>
<A NAME="lbCM">&nbsp;</A>
<H3>Arguments numériques</H3>

<P>


<DL COMPACT>
<DT><B>digit-argument (M-0, M-1, ..., M--)</B>

<DD>
Ajouter le chiffre aux arguments déjà présents, ou créer un nouvel
argument. M-- crée un argument négatif.
<DT><B>universal-argument</B>

<DD>
Il s'agit d'une autre manière d'indiquer un argument.
Si cette commande est suivie d'un ou plusieurs chiffres éventuellement précédés
d'un signe moins, ces chiffres consituent un argument.
Si la commande est suivie de chiffres, une nouvelle exécution de
<B>universal-argument</B>

termine l'argument numérique, mais est ignorée dans les autres cas.
De plus, si la commande est suivie immédiatement par un caractère autre qu'un
chiffre ou le signe moins, le compteur d'argument de la commande suivante
est multiplié par 4.
Le compteur d'argument est initialement à un, ainsi la première exécution
de cette commande l'amène à quatre, la seconde
à seize, et ainsi de suite.

</DL>
<A NAME="lbCN">&nbsp;</A>
<H3>Complétion</H3>

<P>


<DL COMPACT>
<DT><B>complete (TAB)</B>

<DD>
Essayer d'effectuer une complétion du texte situé avant le curseur.
<B>Bash</B>

effectue la complétion en considérant successivement le texte comme
une variable  (s'il commence par <B>$</B>), un nom d'utilisateur (s'il
commence par <B>~</B>), un nom d'hôte (s'il commence par <B>@</B>), ou
une commande (y compris les alias et les fonctions).
Si rien ne fonctionne, il essaye la complétion en nom de fichier.
<DT><B>possible-completions (M-?)</B>

<DD>
Affiche la liste des complétions possibles pour le texte situé avant le curseur.
<DT><B>insert-completions (M-*)</B>

<DD>
Insérer avant le curseur l'ensemble des complétions qui
seraient fournies par
<B>possible-completions</B>.
<DT><B>menu-complete</B>

<DD>
Comme <B>complete</B>, mais en remplaçant le mot à compléter par une seule
correspondance de la liste des complétions possibles.
Des exécutions répétées de <B>menu-complete</B> parcourrent la liste des
complétions possibles, en insérant une correspondance à chaque fois.
À la fin de la liste des complétions, l'alarme sonore est déclenchée et le
texte initial est récupéré.
Un argument <I>n</I> déplace de <I>n</I> positions dans la liste de 
correspondances. Un argument négatif peut être utilisé pour revenir en
arrière dans la liste.
Cette commande est prévue pour être associée à la touche <B>TAB</B>,
mais n'est pas affectée par défaut.
<DT><B>delete-char-or-list</B>

<DD>
Effacer le caractère sous le curseur sauf au début ou en fin de ligne
(comme <B>delete-char</B>).
En fin de ligne, se comporte comme
<B>possible-completions</B>.
Cette commande n'est associée à aucune touche par défaut.
<DT><B>complete-filename (M-/)</B>

<DD>
Essayer la complétion des noms de fichiers sur le texte situé avant le curseur.
<DT><B>possible-filename-completions (C-x /)</B>

<DD>
Affiche la liste des complétions possibles en noms de fichiers pour le
texte situé avant le curseur.
<DT><B>complete-username (M-~)</B>

<DD>
Essayer la complétion des noms d'utilisateurs sur le texte situé avant le
curseur.
<DT><B>possible-username-completions (C-x ~)</B>

<DD>
Affiche la liste des complétions possibles en noms d'utilisateurs pour le
texte situé avant le curseur.
<DT><B>complete-variable (M-$)</B>

<DD>
Essayer la complétion des noms de variables shell sur le texte situé avant le
curseur.
<DT><B>possible-variable-completions (C-x $)</B>

<DD>
Affiche la liste des complétions possibles en noms de variables shell pour le
texte situé avant le curseur.
<DT><B>complete-hostname (M-@)</B>

<DD>
Essayer la complétion des noms d'hôtes sur le texte situé avant le
curseur.
<DT><B>possible-hostname-completions (C-x @)</B>

<DD>
Affiche la liste des complétions possibles en noms d'hôtes pour le
texte situé avant le curseur.
<DT><B>complete-command (M-!)</B>

<DD>
Essayer la complétion des commandes sur le texte situé avant le
curseur. La complétion des commandes inclut les alias, les
mots réservés, les fonctions shell, les fonctions internes, et
finalement les exécutables, dans cet ordre.
<DT><B>possible-command-completions (C-x !)</B>

<DD>
Affiche la liste des complétions possibles en noms de commandes pour le
texte situé avant le curseur.
<DT><B>dynamic-complete-history (M-TAB)</B>

<DD>
Essayer la complétion du texte situé avant le curseur, en recherchant
dans la liste
d'historique.
<DT><B>complete-into-braces (M-{)</B>

<DD>
Renvoie entre accolades la liste des complétions possibles en noms de fichiers
du texte avant le curseur, afin qu'elle soit utilisable par le shell (voir
<B>Expansion des Accolades</B>

plus haut).

</DL>
<A NAME="lbCO">&nbsp;</A>
<H3>Macros Claviers</H3>

<P>


<DL COMPACT>
<DT><B>start-kbd-macro (C-x ()</B>

<DD>
Démarre la mémorisation dans la macro en cours des caractères tapés.
<DT><B>end-kbd-macro (C-x ))</B>

<DD>
Arrête la mémorisation dans la macro en cours des caractères tapés,
et sauvegarde la définition.
<DT><B>call-last-kbd-macro (C-x e)</B>

<DD>
Ré-exécute la dernière macro définie, en agissant comme si les caractères
contenus dans cette macro étaient tapés au clavier.

</DL>
<A NAME="lbCP">&nbsp;</A>
<H3>Divers</H3>

<P>


<DL COMPACT>
<DT><B>re-read-init-file (C-x C-r)</B>

<DD>
Lire le contenu du fichier d'initialisation personnalisée, en incorporant
les assignations de variables, ou les affectations de touches qui s'y trouvent.
<DT><B>abort (C-g)</B>

<DD>
Abandonner l'édition en cours et déclencher l'avertisseur sonore (soumis à la
configuration de la variable
<B>bell-style</B>).

<DT><B>do-uppercase-version (M-a, M-b, M-</B><I>x</I>, ..)

<DD>
Si le caractère précédé de Méta <I>x</I> est en minuscule,
exécuter la commande correspondant aux caractères majuscules indiqués.
<DT><B>prefix-meta (ESC)</B>

<DD>
Considérer le prochain caractère tapé comme une séquence Meta.
<FONT SIZE="-1"><B>ESC</B>

</FONT>
<B>f</B>

est équivalent à
<B>Meta-f</B>.

<DT><B>undo (C-_, C-x C-u)</B>

<DD>
Fonction d'annulation incrémentale, chaque ligne étant mémorisée séparément.
<DT><B>revert-line (M-r)</B>

<DD>
Annuler toutes les modifications sur cette ligne. Ceci est équivalent à répéter
<B>undo</B>

en nombre suffisant pour ramener la ligne à son état initial.
<DT><B>tilde-expand (M-~)</B>

<DD>
Effectuer le développement du tilde sur le mot en cours.
<DT><B>set-mark (C-@, M-&lt;space&gt;)</B>

<DD>
Placer une marque à la position actuelle. Si un argument numérique est fourni,
la marque est posée à l'emplacement correspondant.
<DT><B>exchange-point-and-mark (C-x C-x)</B>

<DD>
Échanger le curseur et la marque. Le curseur est placée à la position
sauvegardée précédemment, et l'ancien curseur est mémorisé par la marque.
<DT><B>character-search (C-])</B>

<DD>
Un caractère est lu et le curseur déplacé à l'occurrence suivante de ce
caractère. Un argument négatif recherche les occurrences précédentes.
<DT><B>character-search-backward (M-C-])</B>

<DD>
Un caractère est lu et le curseur déplacé à l'occurrence précédente de ce 
caractère. Un argument négatif recherche les occurrences suivantes.
<DT><B>insert-comment (M-#)</B>

<DD>
La de la variable
<B>readline</B>

<B>comment-begin</B>

est insérée au début de la ligne en cours, et la ligne est validée comme
si on avait tappé Newline. Ceci sert à transformer la ligne en cours en 
commentaire du shell.
<DT><B>glob-expand-word (C-x *)</B>

<DD>
Le mot précédant le curseur est considéré comme un motif d'expansion de nom de
fichier et la liste des possibilités est insérée à sa place.
<DT><B>glob-list-expansions (C-x g)</B>

<DD>
Le liste des expansions qui aurait été produite pa
<B>glob-expand-word</B>

est affichée et la ligne est rafraîchie.
<DT><B>dump-functions</B>

<DD>
Afficher toutes les fonctions et leurs assignations de touches
sur le flux de sortie de readline. Si un argument numérique est
présent, la sortie est mise en forme pour être compatible avec le
format d'un fichier <I>inputrc</I>.
<DT><B>dump-variables</B>

<DD>
Afficher toutes les variables Readline modifiables et leurs valeurs sur
le flux de sortie. Si un argument numérique est fournie, la sortie est
formatée pour pouvoir être acceptée comme contenu d'un
fichier <I>inputrc</I>.
<DT><B>dump-macros</B>

<DD>
Afficher toutes les séquences de touches associées à des macros et les chaînes
auxquelles elles correspondent. Un argument numérique réclame que la sortie
soit mise en forme pour être compatible avec le format d'un fichier
<I>inputrc</I>.
<DT><B>display-shell-version (C-x C-v)</B>

<DD>
Afficher des informations sur la version en cours de
<B>bash</B>.


</DL>
<A NAME="lbCQ">&nbsp;</A>
<H2>HISTORIQUE</H2>

Quand l'option
<B>-o history</B>

de la commande
<B>set</B>

est active, l'interpréteur donne accès à un
<I>historique des commandes</I>,
c'est à dire la liste des commandes précédemment utilisées. Le texte des
<FONT SIZE="-1"><B>HISTSIZE</B>

</FONT>
dernières commandes (par défaut 500) est mémorisé dans l'historique. Le shell
les enregistre avant expansion des paramètres et variables
(voir le paragraphe
<FONT SIZE="-1"><B>EXPANSION</B>

</FONT>
plus haut) mais après avoir effectué l'expansion historique, sous contrôle des
variables
<B>HISTIGNORE</B>

et
<FONT SIZE="-1"><B>HISTCONTROL</B>.

</FONT>
Au démarrage, l'historique est initialisé avec le fichier dont le nom est
contenu dans la variable
<FONT SIZE="-1"><B>HISTFILE</B>

</FONT>
(par défaut <I>~/.bash_history</I>).
<FONT SIZE="-1"><B>HISTFILE</B>

</FONT>
est tronqué si nécessaire, pour ne pas dépasser
<FONT SIZE="-1"><B>HISTFILESIZE</B>

</FONT>
lignes.
Lorsqu'un shell interactif se termine, les
<FONT SIZE="-1"><B>HISTSIZE</B>

</FONT>
dernières lignes de l'historique sont copiées dans le fichier
<FONT SIZE="-1"><B>HISTFILE</B>.

</FONT>
Si l'option shell
<B>histappend</B>

(voir la description de
<B>shopt</B>

dans
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas) est active, les lignes sont ajoutées au fichier d'historique,
sinon le fichier est écrasé.
Si la variable
<FONT SIZE="-1"><B>HISTFILE</B>

</FONT>
n'existe pas, ou si le fichier n'est pas accessible en écriture, l'historique
n'est pas enregistré. Après la sauvegarder, le fichier d'historique est tronqué
pour ne pas contenir plus de
<FONT SIZE="-1"><B>HISTFILESIZE</B>

</FONT>
lignes. Si
<FONT SIZE="-1"><B>HISTFILESIZE</B>

</FONT>
n'est pas configurée, aucune troncature n'a lieu.
<P>

La commande interne
<B>fc</B>

(voir le paragraphe
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas) permet d'afficher, d'éditer, ou de ré-exécuter une partie de
l'historique.
La commande interne
<B>history</B>

permet d'afficher l'historique et de manipuler le fichier
d'historique.
Quelque soit le mode d'édition en ligne de commande, des commandes de
recherche sont
disponibles pour accéder à
l'historique.
<P>

Le shell permet de configurer quelles commandes seront sauvées dans la liste
d'historique. Les variables
<FONT SIZE="-1"><B>HISTCONTROL</B>

</FONT>
et 
<FONT SIZE="-1"><B>HISTIGNORE</B>

</FONT>
peuvent demander au shell de ne sauvegarder qu'une partie
des commandes saisies.
L'option shell
<B>cmdhist</B>

si elle est active, demande au shell d'essayer de sauver chaque ligne d'une
commande multiligne dans la même entrée de la liste, en ajoutant des
points-virgules si nécessaire pour préserver l'exactitude de la syntaxe.
L'option shell
<B>lithist</B>

demande de sauvegarder les commandes avec des sauts de lignes incorporés
plutôt que des points-virgules. Voir la description de la commande
<B>shopt</B>

dans
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
pour des détails sur la configuration des options shell.
<A NAME="lbCR">&nbsp;</A>
<H2>EXPANSION DE L'HISTORIQUE</H2>

<P>

Le shell propose des possibilités d'expansion de l'historique qui sont semblables
à celles de
<B>csh.</B>

Ce paragraphe décrit la syntaxe de ces commandes. Elles sont utilisables
par défaut dans les shells interactifs, il est toutefois possible de les
désactiver en utilisant l'option
<B>+H</B>

de la commande interne
<B>set</B>

(voir le paragraphe
<FONT SIZE="-1"><B>COMMANDES INTERNES DU SHELL</B>

</FONT>
plus bas). Les shells non-interactifs n'effectuent pas d'expansion d'historique
par défaut.
<P>

L'expansion de l'historique permet d'insérer des mots de l'historique dans
le flux d'entrée, facilitant la répétition de commande, l'insertion des
arguments d'une ligne antérieure dans la saisie en cours, ou la
correction rapide d'erreur de frappe dans une commande précécente.
<P>

Le développement de l'historique est fait immédiatement après la lecture d'une
ligne complète, avant que le shell ne fasse la séparation des mots.
Il se déroule en deux parties.
La première consiste à déterminer la ligne de
l'historique à utiliser pour les substitutions, 
la seconde permet de sélectionner les parties de la lignes à inclure dans
la nouvelle ligne.
La ligne sélectionnée dans l'historique est l'<I>événement</I>, et les parties
de cette ligne à réutiliser sont des <I>mots</I>.
Plusieurs <I>modificateurs</I> permettent de manipuler les mots sélectionnés.
La ligne est découpée en mots de la même manière que lors d'une saisie,
ainsi plusieurs mots séparés par des <I>méta-caractères</I>, et protégés par des
guillemets sont considérés comme un unique mot.
L'expansion de l'historique est introduite par l'apparition
du caractère d'expansion, qui se trouve être <B>!</B> par défaut.
Seul le  backslash (<B>\</B>) et les apostrophes permettent de protéger le
caractère d'échappement de l'historique, par défaut <B>!</B>.
<P>

Plusieurs options shell, configurables aved la commande interne
<B>shopt</B>

permettent d'ajuster le comportement de l'expansion de l'historique.
Si l'option shell
<B>histverify</B>

est activée (voir la description de la commande interne
<B>shopt</B>)

et si
<B>readline</B>

est utilisée, les substitutions d'historiques ne sont pas transmises
tout de suite à l'analyseur du shell. A la place, la
ligne développée est rechargée dans la mémoire tampon de
<B>readline</B>

pour permettre des modifications ultérieures.
Si
<B>readline</B>

est utilisée et si l'option
<B>histreedit</B>

est activée, une substitution d'historique qui échoue est rechargée
dans la mémoire tampon de
<B>readline</B>

pour correction.
L'option
<B>-p</B>

de la commande interne
<B>history</B>

peut servir à examiner ce qu'une substituion donnera avant
de l'employer réellement.
L'option
<B>-s</B>

de la commande interne
<B>history</B>

permet d'ajouter des commandes à la fin de la liste d'historique sans les
les invoquer effectivement, afin qu'elles soient disponibles pour des
rappels ultérieurs.
<P>

Le shell offre le contrôle des divers caractères utilisés par le mécanisme
d'expansion de l'historique (voir la description de
<B>histchars</B>

plus haut dans le paragraphe
<B>Variables du Shell</B>).

<A NAME="lbCS">&nbsp;</A>
<H3>Indicateur d'événement</H3>

<P>

Un indicateur d'événement est une référence à une ligne de commande dans la liste
d'historique.
<P>


<DL COMPACT>
<DT><B>!</B>

<DD>
Débute une substitution de l'historique, sauf s'il est suivi par un
<B>blanc</B>,

retour-chariot, = ou (.
<DT><B>!</B><I>n</I>

<DD>
Se réfère à la ligne de commande
<I>n</I>.

<DT><B>!-</B><I>n</I>

<DD>
Se réfère à la ligne de commande actuelle moins
<I>n</I>.

<DT><B>!!</B>

<DD>
Est une référence à la commande précédente. C'est un synonyme de `!-1'.
<DT><B>!</B><I>chaîne</I>

<DD>
Référence la plus récente commande commençant par la
<I>chaîne</I>.

<DT><B>!?</B><I>chaîne</I><B>[?]</B>

<DD>
Se réfère à la plus récente commande contenant la
<I>chaîne</I>.

Le <B>?</B> final peut être omis si la
<I>chaîne</I>

est suivie immédiatement d'un retour-chariot.
<DT><B></B><FONT SIZE="+2"><B>^</B></FONT><B></B><I>chaîne_1</I><FONT SIZE="+2">^</FONT><I>chaîne_2</I><FONT SIZE="+2">^</FONT>

<DD>
Substitution rapide. Répéter la dernière commande en remplaçant la
<I>chaîne_1</I>

par la
<I>chaîne_2</I>.

Équivalent à
``!!:s/<I>chaîne_1</I>/<I>chaîne_2</I>/''
(voir <B>Modificateurs</B> plus bas).
<DT><B>!#</B>

<DD>
La ligne entière tapée jusqu'à présent.

</DL>
<A NAME="lbCT">&nbsp;</A>
<H3>Indicateurs de mots</H3>

<P>

Ces indicateurs servent à sélectionner les mots désirés dans un événement.
Un
<B>:</B>

sépare l'indicateur d'événements de l'indicateur de mot. On peut l'omettre si
l'indicateur de mot commence par 
<B>^</B>,

<B>$</B>,

<B>*</B>,

<B>-</B>,

ou
<B>%</B>.

Les mots sont numérotés depuis le début de la ligne, 
le premier étant note 0 (zéro).
Les mots sont insérés dans la ligne courante, séparés par des espaces.
<P>


<DL COMPACT>
<DT><B>0 (zéro)</B>

<DD>
Le zéro-ième mot. Pour le shell, c'est le nom de la 
commande.
<DT><I>n</I>

<DD>
Le <I>n</I>-ième mot.
<DT><B>^</B>

<DD>
Le premier argument, c'est à dire le mot 1.
<DT><B>$</B>

<DD>
Le dernier argument.
<DT><B>%</B>

<DD>
Le mot correspondant à la recherche la plus récente `?<I>chaîne</I>?'.
<DT><I>x</I><B>-</B>y

<DD>
Un intervalle de mots, `-<I>y</I>' permet d'abréger `0-<I>y</I>'.
<DT><B>*</B>

<DD>
Tous les mots sauf le zéro-ième. C'est un synonyme pour `<I>1-$</I>'.
Même s'il n'y a qu'un mot,
<B>*</B>

ne déclenche pas d'erreur, 
simplement la chaîne vide est renvoyée.
<DT><B>x*</B>

<DD>
Abréviation de <I>x-$</I>.
<DT><B>x-</B>

<DD>
Abréviation de <I>x-$</I> comme <B>x*</B>, mais sans le dernier mot.

</DL>
<P>

Si un indicateur de mot est founi sans indication d'événement, la dernière
commande est utilisée.
<A NAME="lbCU">&nbsp;</A>
<H3>Modificateurs</H3>

<P>

Après l'éventuel indicateur de mot, vous pouvez ajouter une séquence de
modificateurs, chacun précédé par un `:'.
<P>


<P>

<DL COMPACT>
<DT><B>h</B>

<DD>
Élimine la fin du chemin d'accès, ne laissant que son début.
<DT><B>t</B>

<DD>
Supprimer tout le début d'un chemin d'accès, en ne laissant que la fin.
<DT><B>r</B>

<DD>
Supprime un suffixe final de la forme <I>.xxx</I>, en ne laissant
que le nom de base.
<DT><B>e</B>

<DD>
Tout supprimer sauf le suffixe final.
<DT><B>p</B>

<DD>
Afficher la nouvelle commande sans l'exécuter.
<DT><B>q</B>

<DD>
Protéger les mots substitués, pour éviter les substitutions futures.
<DT><B>x</B>

<DD>
Protéger les mots substitués, comme avec
<B>q</B>,

mais en faisant la séparation des mots sur les
<B>blancs</B>

et les retour-chariots.
<DT><B>s/</B><I>ancien</I>/<I>nouveau</I>/

<DD>
Remplacer par
<I>nouveau</I>

la première occurrence de
<I>ancien</I>

sur la ligne d'événement. N'importe quel délimiteur peut être utilisé à
la place de /. Le dernier délimiteur est facultatif si c'est le dernier
caractère de la ligne d'événement. Le délimiteur peut être protégé dans
<I>ancien</I>

et
<I>nouveau</I>

par un simple backslash. Si &amp; apparaît dans
<I>nouveau</I>,

il est remplacé par
<I>ancien</I>.

Un simple backslash protégera le &amp;. Si
<I>ancien</I>

est nul, il est remplacé par le dernier
<I>ancien</I>

substitué, ou si aucune substitution n'a eu lieu précédemment,
la dernière
<I>chaîne</I>

dans une 
recherche
<B>!?</B><I>chaîne</I><B>[?]</B>.

<DT><B>&amp;</B>

<DD>
Répéter la substitution précédente.
<DT><B>g</B>

<DD>
Appliquer les changements sur la ligne d'événement entière. On utilise ceci
conjointement à `<B>:s</B>' (par exemple `<B>:gs/</B><I>ancien</I>/<I>nouveau</I>/')
ou `<B>:&amp;</B>'.
S'il est utilisé avec `<B>:s</B>', n'importe quel délimiteur peut être utilisé 
à la place de /, et le dernier délimiteur est facultatif si c'est le dernier
caractère de la ligne d'événement. 

</DL>
<A NAME="lbCV">&nbsp;</A>
<H2>COMMANDES INTERNES DU SHELL</H2>



<P>

Sauf indication contraire, toute commande décrite comme acceptant des options
précédées de
<B>-</B>

accepte également la notation
<B>--</B>

pour signifier la fin de la liste d'options.
<P>

<DL COMPACT>
<DT><B>:</B> [<I>arguments</I>]<DD>

Pas d'effet. Cette commande ne fait rien d'autre que l'expansion des
<I>arguments</I>

et la mise en place des redirections.
Le code de retour est nul.
<DT>
<DD>
<B> . </B> <I>fichier</I> [<I>arguments</I>]
<DT><B>source</B> <I>fichier</I> [<I>arguments</I>]<DD>

Lire et exécuter les commandes contenues dans le
<I>fichier</I>

avec l'environnement du shell en cours,
puis renvoyer le code de retour
de la dernière commande exécutée dans le
<I>fichier</I>.

Si le nom du
<I>fichier</I>

ne contient pas de slash, les chemins d'accès contenus dans
<FONT SIZE="-1"><B>PATH</B>

</FONT>
sont parcourus pour rechercher le répertoire contenant le
<I>fichier</I>.

Lorsqu'il est recherché dans le
<FONT SIZE="-1"><B>PATH</B>

</FONT>
le fichier n'a pas besoin d'être exécutable. Le répertoire de travail
en cours est finalement examiné si aucun fichier n'est trouvé dans le
<FONT SIZE="-1"><B>PATH</B>.

</FONT>
Si l'option
<B>sourcepath</B>

de la commande interne
<B>shopt</B>

est désactivée, le
<FONT SIZE="-1"><B>PATH</B>

</FONT>
n'est pas parcouru.
Si des <I>arguments</I> sont fournis, ils sont transmis dans les
paramètres positionnels lorsque le <I>fichier</I> est exécuté.
Sinon les paramètres positionnel ne sont pas modifiés.
Le code de retour est celui de la dernière commande exécutée au sein
du script (0 si aucune commande n'est exécutée), et faux si le
<I>fichier</I>

n'est pas trouvé.
<DT><B>alias</B> [<B>-p</B>] [<I>nom</I>[=<I>valeur</I>] ...]<DD>
La commande <B>alias</B>, sans argument ou avec l'option
<B>-p</B>

affiche sur la sortie standard la liste des alias actuellement définis,
sous la forme <I>nom</I>=<I>valeur</I>. Lorsque l'on
fournit des arguments, un alias est créé pour chaque <I>nom</I>
auquel on a donné une <I>valeur</I>. 
Un espace final dans une <I>valeur</I> forcera la recherche d'alias dans le mot
suivant lors de l'expansion de l'alias.
Pour chacun des <I>noms</I> pour lesquels aucune <I>valeur</I> n'est fournie dans
la liste d'arguments, le nom et la valeur de l'alias sont affichés.
La commande <B>Alias</B> renvoie vrai, sauf si l'on indique un <I>nom</I> pour
lequel aucun alias n'a été défini.
<DT><B>bg</B> [<I>job</I>]<DD>
Relance en arrière-plan le <I>job</I> suspendu, comme s'il avait été
lancé avec
<B>&amp;</B>.

Si aucun <I>job</I> n'est précisé, le job en cours est basculé
en arrière-plan.
<B>bg</B>

<I>job</I>

renvoie 0 si le contrôle des jobs est désactivé, ou si le <I>job</I>
n'existe pas,
ou encore s'il a été lancé sans contrôle de jobs.
<DT>
<DD>
<B>bind</B> [<B>-m</B> <I>jeu_de_touches</I>] [<B>-lpsvPSV</B>]
<DT><B>bind</B> [<B>-m</B> <I>jeu_de_touches</I>] [<B>-q</B> <I>nom</I>] [<B>-u</B> <I>fonction</I>] [<B>-r</B> <I>séquence</I>]<DD>
<DT><B>bind</B> [<B>-m</B> <I>jeu_de_touches</I>] <B>-f</B> <I>fichier</I><DD>
<DT><B>bind</B> [<B>-m</B> <I>jeu_de_touches</I>] <I>séquence</I>:<I>fonction</I><DD>

Affiche les affectations de touches
<B>readline</B>

pour une fonction, ou affecte une séquence de touches à une fonction ou une macro
<B>readline</B>.

La syntaxe d'affectation est identique à celle des fichiers
<I>.inputrc</I>,

mais chaque affectation doit être fournie sous forme d'argument indépendant,
par exemple '&quot;\C-x\C-r&quot;: re-read-init-file'. Les éventuelles options ont
les significations suivantes :
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>-m </B><I>jeu_de_touches</I>

<DD>
Modifier la configuration du
<I>jeu_de_touches</I>

indiqué.
Les noms des
<I>jeux_de_touches</I>

acceptés sont
<I>emacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,
vi-command</I>, et
<I>vi-insert</I>.

<I>vi</I> est équivalent à <I>vi-command</I>; <I>emacs</I> est
équivalent à <I>emacs-standard</I>.
<DT><B>-l</B>

<DD>
Afficher la liste des noms de toutes les fonctions <B>readline</B>
<DT><B>-p   </B>

<DD>
Affiche les noms des fonctions <B>readline</B> et leurs affectations de
manière à pouvoir les relire.
<DT><B>-P</B>

<DD>
Affiche les noms des fonctions <B>readline</B> et leurs affectations.
<DT><B>-v</B>

<DD>
Affiche les noms des variables <B>readline</B> et leurs valeurs de
manière à pouvoir les relire.
<DT><B>-V</B>

<DD>
Affiche les noms des variables <B>readline</B> et leurs valeurs.
<DT><B>-s</B>

<DD>
Affiche les séquences de touches <B>readline</B> affectées aux macros et 
les chaînes correspondantes, de manière à pouvoir les relire.
<DT><B>-S</B>

<DD>
Affiche les séquences de touches <B>readline</B> affectées aux macros et 
les chaînes correspondantes.
<DT><B>-f </B><I>fichier</I>

<DD>
Lire les affectations dans le <I>fichier</I>
<DT><B>-q </B><I>fonction</I>

<DD>
Rechercher la touche permettant d'invoquer la <I>fonction</I> indiquée
<DT><B>-u </B><I>fonction</I>

<DD>
Désaffecter toutes les touches correspondant à la <I>fonction</I>.
<DT><B>-r </B><I>séquence</I>

<DD>
Supprimer les affectations pour la <I>séquence</I> de touches.

</DL>
<P>

La valeur de retour est nulle, sauf si une option invalide est fournie, ou
si une erreur se produit.
</DL>

<DT><B>break</B> [<I>n</I>]<DD>
Sortir d'une boucle
<B>for</B>,

<B>while</B>,

ou
<B>until</B>.

Si <I>n</I> est fourni, sortir de <I>n</I> niveaux de boucles.
<I>n</I>

doit être &ge; 1.  Si
<I>n</I>

est supérieur au nombre de boucles imbriquées, on sort de l'ensemble
d'entre elles. La valeur de retour est nulle, sauf si le shell
n'exécute pas de boucle lorsque le
<B>break</B>

est atteint.
<DT><B>builtin</B> <I>commande_interne</I> [<I>arguments</I>]<DD>
Exécuter la <I>commande interne</I> du shell indiquée, en lui passant les
<I>arguments</I>,

puis renvoyer son code de retour.
Ceci est utile lorsque l'on veut définir une fonction ayant le même
nom qu'une commande interne, mais que l'on a besoin d'invoquer cette
commande depuis l'intérieur de la fonction.
On redéfinit souvent
la commande interne <B>cd</B> ainsi.
Le code de retour est faux si la
<I>commande_interne</I>

n'existe pas.
<DT><B>cd</B> [<I>rep</I>]<DD>
Remplacer le répertoire de travail en cours par <I>rép</I>. La variable
<FONT SIZE="-1"><B>HOME</B>

</FONT>
est la valeur
par défaut de
<I>rep</I>.

La variable
<FONT SIZE="-1"><B>CDPATH</B>

</FONT>
définit des chemins de recherche pour trouver le répertoire contenant
<I>rép</I>.

Les répertoires possibles
y sont fournis dans une liste
séparées par des
doubles-points (:). Un nom de répertoire nul dans
<FONT SIZE="-1"><B>CDPATH</B>

</FONT>
est équivalent au répertoire en cours, c'est à dire ``<B>.</B>''. Si
<I>rép</I>

commence par un slash (/),
alors
<FONT SIZE="-1"><B>CDPATH</B>

</FONT>
n'est pas utilisé. L'option
<B>-P</B>

demande de n'employer que l'enchaînement réel des répertoires sans
suivre les liens symboliques (voir aussi l'option
<B>-P</B>

de la commande interne
<B>set</B>

plus bas). L'option
<B>-L</B>

force le suivi des liens symboliques. Un argument
<B>-</B>

est équivalent à
<FONT SIZE="-1"><B>$OLDPWD</B>.

</FONT>
La valeur de retour est vraie si l'on a pu changer le répertoire de
travail, et fausse sinon.
<DT><B>command</B> [<B>-pVv</B>] <I>commande</I> [<I>arguments</I> ...]<DD>
Lancer la
<I>commande</I>

avec les
<I>arguments</I>

indiqués, mais en simplifiant le processus habituel de recherche des commandes.
Seules les commandes internes, et les commandes disque trouvées dans le
<FONT SIZE="-1"><B>PATH</B>

</FONT>
seront exécutées. Si l'option
<B>-p</B>

est fournie, la recherche de la
<I>commande</I>

utilisera une valeur par défaut du
<B>PATH</B>

garantissant de trouver tous les utilitaires standards.
Si l'option
<B>-V</B>

ou l'option
<B>-v</B>

sont fournies, une description de la 
<I>commande</I>

est affichée. L'option
<B>-v</B>

n'affiche qu'un simple mot indiquant la commande interne, ou le chemin
d'accès utilisé pour invoquer la
<I>commande</I>.

L'option
<B>-V</B>

fournit une description plus volubile.
Si les options
<B>-V</B>

ou
<B>-v</B>

sont fournies, le code de retour est 0 si la
<I>commande</I>

est trouvée, et 1 sinon. Si aucune option n'est fournie, et si une erreur
se produit, ou si la
<I>commande</I>

est introuvable, le code de retour est 127. Sinon, le code de retour de
cette commande interne est celui de la
<I>commande </I>

invoquée.
<DT><B>continue</B> [<I>n</I>]<DD>
Reprendre l'exécution à l'itération suivante d'une boucle
<B>for</B>,

<B>while</B>,

<B>until</B>,

ou
encore
<B>select</B>.

Si 
<I>n</I>

est indiqué, reprendre l'exécution à la <I>n</I>-ième boucle imbriquée.
<I>n</I>

doit être &ge; 1.  Si
<I>n</I>

est supérieur au nombre de boucles imbriquées, l'exécution reprend à
la boucle la plus externe (`top-level'). La valeur de retour est 0
sauf si le shell n'exécutait pas de boucle quand il a rencontré
l'instruction
<B>continue</B>.

<DT>
<DD>
<B>declare</B> [<B>-afFirx</B>] [<B>-p</B>] [<I>nom</I>[=<I>valeur</I>]]
<DT><B>typeset</B> [<B>-afFirx</B>] [<B>-p</B>] [<I>nom</I>[=<I>valeur</I>]]<DD>

Déclarer des variables et/ou leur fournir des attributs.
Si aucun <I>nom</I> n'est mentionné, les valeurs des variables sont affichées.
L'option
<B>-p</B>

affichera les attributs et les valeurs de chaque
<I>nom</I>.

Quand
<B>-p</B>

est utilisée, les autres options sont ignorées.
L'option
<B>-F</B>

évite l'affichage des définitions de fonctions, seuls les
noms des fonctions et leurs attributs sont affichés.
L'option
<B>-F</B>

implique l'usage de
<B>-f .</B>

Les options suivantes permettent
de restreindre l'affichage aux variables dotées de certains attributs,
ou de fixer les attributs.
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>-a</B>

<DD>
Chaque <I>nom</I> est une variable de type tableau (voir le paragraphe
<B>Tableaux</B>

plus haut).
<DT><B>-f</B>

<DD>
Seulement les noms de fonctions
<DT><B>-i</B>

<DD>
La variable est traitée comme un entier. L'évaluation arithmétique (voir
<FONT SIZE="-1"><B>ÉVALUATION ARITHMÉTIQUE ) </B>

</FONT>
est effectuée lorsque la variable reçoit une valeur.
<DT><B>-r</B>

<DD>
Rend les <I>nom</I>s accessibles en lecture seulement. On ne pourra plus modifier
les valeurs de ces noms lors d'assignations ultérieures.
<DT><B>-x</B>

<DD>
Marquer le <I>nom</I> pour qu'il soit exporté dans l'environnement.

</DL>
<P>

En utilisant `+' a la place de `-', l'attribut correspondant est
désactivé.
Dans une fonction,
chacun 
des <I>noms</I> devient local, comme avec la commande
<B>local</B>.

La valeur de retour est 0 sauf si une option illégale est rencontrée,
si on essaye de définir une fonction en utilisant &quot;-f foo=bar&quot;,
si on tente d'écrire dans une variable en lecture seule,
si on essaye d'affecter une valeur a une variable tableau sans
employer la syntaxe composée (voir
<B>Tableaux</B>

plus haut), si l'un des <I>noms</I> n'est pas un nom légal pour le shell,
si on essaye de supprimer l'attribut lecture-seule d'une variable,
si on essaye de supprimer l'attribut tableau d'une variable,
ou si on essaye d'afficher avec -f une fonction inexistante.
</DL>

<DT><B>dirs [-clpv</B>] [<B>+/-n</B>]

<DD>
Affiche la liste des répertoires actuellement mémorisés.
L'affichage par défaut se fait sur une seule ligne, les noms de répertoires
étant séparés par des espaces.
On ajoute des répertoires dans cette liste avec la commande
<B>pushd</B>,

et on peut en
supprimer avec la commande
<B>popd</B>.

<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>+</B> <I>n</I><DD>
affiche le <I>n</I>-ième élément de la 
liste fournie par
<B>dirs</B>

sans options, en comptant à partir de la gauche en commençant à zéro.
<DT><B>-</B> <I>n</I><DD>
affiche le <I>n</I>-ième élément de la liste
fournie par
<B>dirs</B>

sans options, en comptant à partir de la droite en commençant à zéro.
<DT><B>-c</B>

<DD>
Effacer la liste des répertoires en les supprimant tous.
<DT><B>-l</B>

<DD>
affiche une liste longue, le format par défaut utilisant le tilde
pour représenter le répertoire personnel.
<DT><B>-p</B>

<DD>
Afficher la liste des répertoires avec un élément par ligne.
<DT><B>-v</B>

<DD>
Afficher la liste des répertoires avec un élément par ligne,
en préfixant chaque entrée avec son numméro d'index dans la liste.

</DL>
<P>

La valeur de retour est 0 sauf si une option illégale a été trouvée,
ou si l'index <I>n</I> dépasse la longueur
de la pile des répertoires.
</DL>

<DT><B>disown</B> [<B>-ar</B>] [<B>-h</B>] [<I>job</I> ...]<DD>
Sans options, chaque
<I>job</I>

est supprimé de la table des jobs actifs.
Si l'option <B>-h</B> est fournie, chaque
<I>job</I>

n'est pas supprimé mais est marqué pour que le signal
<FONT SIZE="-1"><B>SIGHUP</B>

</FONT>
ne lui soit pas envoyé si le shell reçoit un signal
<FONT SIZE="-1"><B>SIGHUP</B>.

</FONT>
Si aucune
<I>job</I>

n'est indiqué, et si ni l'option
<B>-a</B>

ni l'option
<B>-r</B>

ne sont fournies, le <I>job en cours</I> est concerné.
Si aucun 
<I>job</I>

n'est indiqué, l'option
<B>-a</B>

signifie la suppression ou le marquage de tous les jobs ; l'option
<B>-r</B>

sans spécification de
<I>job</I>

restreint les opérations au job en cours.
La valeur renvoyée est zéro sauf si un
<I>job</I>

indiqué n'est pas valide.
<DT><B>echo</B> [<B>-neE</B>] [<I>arguments</I> ...]<DD>
Affiche ses <I>arguments</I>s, séparés par des espaces. 
La valeur de retour est toujours nulle.
Avec l'option <B>-n</B>, le retour-chariot final est supprimé.
Avec l'option <B>-e</B> l'interprétation des séquences d'échappement
est activée. L'option
<B>-E</B>

désactive l'interprétation des séquences d'échappement, même sur les
systèmes où elles sont interprétées par défaut.
<B>echo</B>

n'interprète pas la séquence
<B>--</B>

comme une marque de fin des options.
<B>echo</B>

reconnaît les séquences d'échappement suivantes :
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>\a</B>

<DD>
alerte (avertisseur sonore)
<DT><B>\b</B>

<DD>
backspace
<DT><B>\c</B>

<DD>
suppression du retour-chariot final
<DT><B>\e</B>

<DD>
caractère d'échappement
<DT><B>\f</B>

<DD>
saut de page
<DT><B>\n</B>

<DD>
nouvelle ligne
<DT><B>\r</B>

<DD>
retour-chariot
<DT><B>\t</B>

<DD>
tabulation horizontale
<DT><B>\v</B>

<DD>
tabulation verticale
<DT><B>\\</B>

<DD>
backslash
<DT><B>\</B><I>nnn</I>

<DD>
le caractère dont le code ASCII octal vaut <I>nnn</I>
(un à trois chiffres)
<DT><B>\x</B><I>nnn</I>

<DD>
le caractère dont le code ASCII hexadécimal vaut <I>nnn</I>
(un à trois chiffres)

</DL>
</DL>

<DT><B>enable</B> [<B>-adnps</B>] [<B>-f</B> <I>fichier</I>] [<I>nom</I> ...]<DD>
Active ou inhibe les commandes internes du shell. Ceci permet
d'exécuter une commande disque ayant le même nom qu'une commande
interne du shell, sans avoir besoin d'indiquer le chemin d'accès
complet.
Avec l'option <B>-n</B>, chaque <I>nom</I> indiqué est inhibé,
sinon
ils sont activés. Par exemple, pour utiliser le programme binaire
<B>test</B>

qui se trouve dans le
<FONT SIZE="-1"><B>PATH</B>

</FONT>
plutôt que la commande interne, utilisez
<I>enable -n test</I>.
L'option
<B>-f</B>

demande de charger la commande interne avec le
<I>nom</I>

indiqué depuis le
<I>fichier</I>

objet partagé sur les systèmes qui le permettent. L'option
<B>-d</B>

permet de supprimer une commande interne chargée précédemment avec
<B>-f</B>.

Si aucun <I>nom</I> n'est fourni, ou si l'option
<B>-p</B>

est indiquée, la liste des commandes internes du shell est affichée.
Sans autre option, la liste des commandes actives 
est imprimée.
Avec l'option <B>-n</B>, seules les commandes désactivées sont affichées.
Si l'option <B>-a</B> est fournie, la liste de toutes les commandes est
affichée, avec une indication des activations et inhibitions.
Si on indique <B>-s</B>, la sortie est limitée aux commandes internes
spéciales POSIX.
La valeur de retour est 0, sauf si
<I>nom</I>

n'est pas une commande interne, ou s'il y a un problème
avec le chargement d'une nouvelle commande.
<DT><B>eval</B> [<I>arguments</I> ...]<DD>
Les <I>arguments</I> sont lus et regroupés en une seule commande simple. Cette
commande est alors lue et exécutée par le shell, et son code de retour est
renvoyée comme valeur de la commande
<B>eval</B>.

S'il n'y a pas 
d'<I>arguments</I>, ou 
uniquement des arguments nuls,
<B>eval</B>

renvoie vrai.
<DT><B>exec</B> [<B>-cl</B>] [<B>-a</B> <I>nom</I>] [<I>commande</I> [<I>arguments</I>]]<DD>
Si une
<I>commande</I>

est indiquée, elle remplace le shell.
Aucun nouveau processus n'est créé. Les
<I>arguments</I>

deviennent ceux de la <I>commande</I>.
Si l'option
<B>-l</B>

est fournie,
l'interpréteur place un tiret en guise de zéro-ième argument fourni a la
<I>commande</I>.

C'est ce que fait
<I>login</I>.

L'option
<B>-c</B>

permet d'exécuter la
<I>commande </I>

avec un environnement vide. Si l'option
<B>-a</B>

est indiquée, le shell transmet le
<I>nom</I>

comme zéro-ième argument. Si la
<I>commande</I>

Si la commande ne peut être exécutée, quelqu'en soit la raison, un shell
non-interactif se termine, sauf si l'option shell
<B>execfail</B>

est active, auquel cas une erreur est renvoyée.
Un shell interactif renvoie l'erreur si le fichier ne peut pas être exécuté.
Si aucune
<I>commande</I>

n'est indiquée, les éventuelles redirections sont mises en place dans le
shell en cours, et le code de retour est 0. S'il y a un problème de
redirection, le code de retour est 1.
<DT><B>exit</B> [<I>n</I>]<DD>
Termine le shell avec le code
de retour <I>n</I>. Si
<I>n</I>

est omis, le code de retour sera celui de la 
dernière commande exécutée.
Un éventuel gestionnaire installé sur
<FONT SIZE="-1"><B>EXIT</B>

</FONT>
sera exécuté avant la fin du shell.
<DT>
<DD>
<B>export</B> [<B>-nf</B>] [<I>nom</I>[=<I>mot</I>]] ...
<DT><B>export -p</B>

<DD>

Les
<I>noms</I>

indiqués sont marqués pour être exportés automatiquement dans l'environnement
des commandes exécutées par la suite. Si l'option
<B>-f</B>

est fournie,
les
<I>noms</I>

sont ceux de fonctions.
Si aucun
<I>nom</I>

n'est mentionné, ou si l'option
<B>-p</B>

est fournie, une liste est affichée indiquant l'ensemble des
noms exportables par ce shell.
L'option
<B>-n</B>

supprime l'attribut d'exportation des variables
mentionnées.
<B>export</B>

renvoie un code de retour nul, sauf si une option illégale est
rencontrée, ou si l'un des <I>noms</I> n'est pas un nom de variable
légal, ou si l'option
<B>-f</B>

est fournie avec un
<I>nom</I>

qui ne soit pas une fonction.
<DT>
<DD>
<B>fc</B> [<B>-e</B> <I>éditeur</I>] [<B>-nlr</B>] [<I>premier</I>] [<I>dernier</I>]
<DT><B>fc</B> <B>-s</B> [<I>motif</I>=<I>nouveau</I>] [<I>commande</I>]<DD>

(Fix Command). Avec la première forme, un intervalle de commandes, entre la
<I>première</I>

et la
<I>dernière</I>,

est sélectionné dans la liste d'historique. La
<I>première </I>

et la
<I>dernière</I>

peuvent être indiquées sous forme de chaînes (la dernière
commande commençant par la chaîne indiquée), ou sous forme numérique (un
index dans la liste d'historique, ou un nombre négatif indiquant un
décalage par rapport à la position actuelle dans cette liste).  Si la
<I>dernière</I>

n'est pas indiquée, on considère qu'il s'agit de la commande en cours
si l'on veut afficher la liste (ainsi
<B>fc -l -10</B>

affiche les 10 dernières commandes), et qu'il s'agit de la même que la
<I>première</I>

sinon.
Si la
<I>première</I>

n'est pas indiquée, on considère qu'il s'agit de la commande
précédente pour une édition, et de la commande -16 pour l'affichage de liste.
<P>
L'option
<B>-n</B>

supprime l'affichage des numéros dans la liste.
L'option
<B>-r</B>

inverse l'ordre des commandes
Avec l'option
<B>-l</B>

les commandes sont affichées sur la sortie
standard.
Sinon,
l'<I>éditeur</I>
est invoqué avec un fichier
contenant les commandes sélectionnées. Si aucun
<I>éditeur</I>

n'est précisé, on utilise la valeur de
la variable
<FONT SIZE="-1"><B>FCEDIT</B>,

</FONT>
ou la
valeur de
<FONT SIZE="-1"><B>EDITOR</B>

</FONT>
si
<FONT SIZE="-1"><B>FCEDIT</B>

</FONT>
n'existe pas. Si aucune variable n'existe,

<I>vi</I>

est invoqué. Lorsque l'édition se termine, les commandes sont affichées puis
exécutées.
<P>
Dans la seconde forme, la <I>commande</I> est ré-exécutée après avoir
remplacé chaque instance du <I>motif</I> par <I>nouveau</I>.
Un alias utile pour ceci est
``r=fc -s'',

ainsi en tapant
``r cc''

on relance la dernière commande commençant par
``cc''

et en tapant ``r''
``r''

on ré-exécute la commande précédente.
<P>
Lorsque la première forme est utilisée, la valeur renvoyée est 0, sauf si
une option illégale est trouvée, ou si
<I>première</I>

ou
<I>dernière</I>

indiquent des lignes d'historique inexistantes.
Avec l'option
<B>-e</B>,

la valeur de retour est celle de la dernière commande exécutée, ou
un échec si une erreur s'est produite avec le fichier temporaire des
commandes. Avec la seconde forme, le code de retour est celui de
la commande ré-exécutée, à moins que
<I>commande</I>

ne soit pas une ligne valide de l'historique, auquel cas
<B>fc</B>

renvoie un échec.
<DT><B>fg</B> [<I>job</I>]<DD>
Placer le
<I>job</I>

en avant-plan,  et en faire le job en cours.
Si aucun
<I>job</I>

n'est mentionné, le shell considèrera qu'il faut ramener le <I>job en cours</I>
en avant-plan.
La valeur de retour est celle de la commande placée en avant-plan, ou un échec
si le contrôle des jobs n'est pas actif, ou encore si le
<I>job</I>

n'existe pas ou a été lancé 
sans contrôle 
des jobs.
<DT><B>getopts</B> <I>chaîne_d_options</I> <I>nom</I> [<I>arguments</I>]<DD>
<B>getopts</B>

est utilise par les scripts shell pour analyser les paramètres positionnels. La 
<I>chaîne_d_options</I>

contient l'ensemble des lettres d'options à reconnaître. Si une lettre est
suivie par un deux-points (:), l'option est censée comprendre un argument,
qui peut en être séparé par une espace.
A chaque invocation, 
<B>getopts</B>

place l'option suivante dans la variable shell dont le
<I>nom </I>

est fourni,
en la créant
si elle n'existe pas.
Il place également l'index de l'argument suivant à analyser dans
la variable
<FONT SIZE="-1"><B>OPTIND</B>.

</FONT>
<FONT SIZE="-1"><B>OPTIND</B>

</FONT>
est initialisé à 1 à chaque lancement d'un shell ou d'un script.
Quand une option nécessite un argument, 
<B>getopts</B>

place celui-ci dans la variable
<FONT SIZE="-1"><B>OPTARG</B>.

</FONT>
Le shell ne réinitialise pas
<FONT SIZE="-1"><B>OPTIND</B>

</FONT>
automatiquement, il faut le faire manuellement si des appels
multiples à 
<B>getopts</B>

au sein du même shell utilisent des ensembles différents de
paramètres.
<P>
Lorsque la fin des options est atteinte, <B>getopts</B> se termine
avec un code de retour supérieur à zéro.
<B>OPTIND</B> est rempli avec le rang du premier argument non-option,
et <B>nom</B> contient '?'.
<P>
<B>getopts</B>

analyse en principe les paramètres positionnels, mais si d'autres
<I>arguments </I>

lui sont transmis,
<B>getopts</B>

analysera ces derniers.
<P>
<B>getopts</B>

peut renvoyer des erreurs de deux manières. Si le premier caractère de la
<I>chaîne_d_options</I>

est un deux-points, les erreurs sont renvoyées de manière
<I>silencieuse</I>.

Lors d'un fonctionnement normal, des messages de diagnostique sont
affichés si une option est illégale, ou s'il manque un argument
d'option.
Si la variable
<FONT SIZE="-1"><B>OPTERR</B>

</FONT>
vaut 0, aucun message d'erreur ne sera affiché, même si le premier
caractère de la 
<I>chaîne_d_options</I>

n'est pas un deux-points.
<P>
Si une option illégale est rencontrée, 
<B>getopts</B>

met un point d'interrogation ? dans la variable
<I>nom</I>,

affiche un message d'erreur (s'il n'est pas en mode silencieux), et
détruit la variable
<FONT SIZE="-1"><B>OPTARG</B>.

</FONT>
Si
<B>getopts</B>

fonctionne en mode silencieux,
le caractère d'option est placé dans
<FONT SIZE="-1"><B>OPTARG</B>

</FONT>
et aucun message de diagnostique n'est affiché.
<P>
Lorsqu'un argument d'option est manquant, et si
<B>getopts</B>

n'est pas silencieux,
un point d'interrogation (<B>?</B>) est placé dans la variable
<I>nom</I>,

<B>OPTARG</B>

est détruit, et un message de diagnostique est affiché.
Si
<B>getopts</B>

est silencieux, un deux-points (<B>:</B>) est placé dans la variable
<I>nom</I>

et
<FONT SIZE="-1"><B>OPTARG</B>

</FONT>
est rempli avec le caractère d'option trouvé.
<P>
<B>getopts</B>

renvoie la valeur Vrai si une option, prévue ou imprévue, est trouvée.
Il renvoie Faux si la fin des options est atteinte, ou si une erreur
se produit.
<DT><B>hash</B> [<B>-r</B>] [<B>-p</B> <I>fichier</I>] [<I>nom</I>]<DD>
Pour chaque
<I>nom </I>

fourni, le chemin d'accès complet de la commande est déterminé,
en examinant les répertoires de
<B>$PATH</B>

et mémorisé.
Si l'option
<B>-r</B>

est fournie, aucune recherche de chemin d'accès n'a lieu, et le
<I>fichier</I>

est utilisé comme chemin complet pour la commande.
L'option
<B>-r</B>

force le shell à oublier tous les emplacements mémorisés.
Sans arguments, <B>hash</B> affiche des informations sur les
commandes mémorisées.
La valeur de retour est Vrai, sauf si
<I>nom</I>

n'est pas trouvé, ou si une option est illégale.
<DT><B>help</B> [<I>motif</I>]<DD>
Affiche des informations d'aide au sujet des commandes internes. Si un
<I>motif</I>

est indiqué,
<B>help</B>

fournit de l'aide sur toutes les commandes correspondant à ce
<I>motif</I>,

sinon, une liste des commandes internes est affichée. Le code de retour
est 0, sauf si aucune commande ne peut correspondre au
<I>motif</I>.

<DT>
<DD>
<B>history</B> [<B>-c</B>] [<I>n</I>]
<DT><B>history</B> <B>-anrw</B> [<I>fichier</I>]<DD>
<DT><B>history</B> <B>-p</B> <I>arg</I> [<I>argument ...</I>]<DD>
<DT><B>history</B> <B>-s</B> <I>arg</I> [<I>argument ...</I>]<DD>

Sans options, affiche la liste des commandes de l'historique, avec des
numéros de ligne. Les lignes marquées
avec un astérisque
<B>*</B>

ont été modifiées. Un argument
<I>n</I>

permet de ne lister que les
<I>n</I>

dernières lignes. Si un argument est fourni, il est utilisé comme nom
de fichier historique, sinon on utilise la valeur de la variable
<FONT SIZE="-1"><B>HISTFILE</B>.

</FONT>
Les options ont les significations suivantes :
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>-a</B>

<DD>
Ajouter les ``nouvelles'' lignes d'historiques (celles créées depuis
le début de la session actuelle de <B>bash</B>) dans le fichier.
<DT><B>-n</B>

<DD>
Lire dans le fichier, et ajouter à la liste d'historique, les lignes 
non encore lues. Il s'agit des lignes qui ont été ajoutées dans le
fichier depuis le début 
de la session actuelle de <B>bash</B>.
<DT><B>-r</B>

<DD>
Lire le contenu du fichier, et 
l'utiliser comme historique courant.
<DT><B>-w</B>

<DD>
Écrire dans le fichier l'historique actuel, 
en écrasant le contenu precedent.
<DT><B>-c</B>

<DD>
Effacer le fichier d'historique en détruisant toutes ses entrées.
<DT><B>-p</B>

<DD>
Effectuer la substitution sur les arguments suivants, et afficher
le résultat sur la sortie standard.
Ne pas mémoriser les résultats dans la liste d'historique.
Chaque <I>argument</I> doit être protégé pour éviter le développement normal.
<DT><B>-s</B>

<DD>
Enregistrer les
<I>arguments</I>

dans la liste d'historique comme entrée unique. La dernière commande de
la liste d'historique est supprimée avant que les
<I>arguments</I>

soient ajoutés.

</DL>
<P>

La valeur de retour est 0, sauf si une option illégale est fournie, ou si
une erreur se produit durant la lecture ou l'écriture du fichier.
</DL>

<DT>
<DD>
<B>jobs</B> [<B>-lnprs</B>] [ <I>job</I> ... ]
<DT><B>jobs</B> <B>-x</B> <I>commande</I> [ <I>arguments</I> ... ]<DD>

La première forme affiche la liste de jobs actifs. Les options ont
les significations suivantes :
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>-l</B>

<DD>
Affiche les PIDs,
en plus des informations normales. 
<DT><B>-p</B>

<DD>
N'affiche que le PID du leader du groupe 
de processus du job.
<DT><B>-n</B>

<DD>
N'affiche que les jobs dont le statut a varié depuis le dernier
affichage.
<DT><B>-r</B>

<DD>
N'affiche que les jobs en cours d'exécution (running).

<B>-s</B>

N'affiche que les jobs arrêtés (stopped).

</DL>
<P>

Si une spécification de
<I>job</I>

est fournie, l'affichage ne comporte que les informations à propos de ce job.
Le code de retour est 0, à moins qu'une option illégale
soit transmise, ou que le 
<I>job</I>

n'existe pas.
<P>

Si l'option
<B>-x </B>

est indiquée,
<B>jobs</B>

va remplacer toutes les 
spécifications de jobs 
rencontrées dans la
<I>commande</I>

ou dans ses
<I>arguments</I>

avec les Process Group ID correspondant, puis il exécutera la
<I>commande</I>

en lui transmettant les
<I>arguments</I>,

et en renvoyant son code de retour.
</DL>

<DT>
<DD>
<B>kill</B> [<B>-s</B> <I>sigspec</I> | <B>-n</B> <I>num-signal</I> | <B>-</B><I>sigspec</I>] [<I>pid</I> | <I>job</I>] ...
<DT><B>kill</B> <B>-l</B> [<I>sigspec</I> | <I>exit_status</I>]<DD>

Envoyer le signal indiqué par
<I>sigspec</I>

ou
<I>num-signal</I>

aux processus spécifiés par 
<I>pid</I>

ou par
<I>job</I>.

On peut fournir
<I>sigspec</I>

sous forme numérique,
ou sous forme de nom
de signal, comme
<FONT SIZE="-1"><B>SIGKILL</B>.

</FONT>
Si
<I>sigspec</I>

est un nom de signal, il n'y a pas de différenciation majuscules/minuscules,
et le préfixe
<FONT SIZE="-1"><B>SIG</B>

</FONT>
est facultatif.
S'il n'y a pas d'indication de
<I>sigspec</I>,

le signal
envoyé est
<FONT SIZE="-1"><B>SIGTERM</B>.

</FONT>
Un argument
<B>-l</B>

fournit la liste des noms de signaux. S'il y a des arguments avec
l'option
<B>-l</B>,

les noms des signaux indiqués sont affichés, et le code de retour est
nul.
L'argument <I>exit_status</I> de l'option
<B>-l</B>

est un nombre correspondant soit à un numéro de signal soit au code
de retour renvoyé par un processus tué par un signal.
<B>kill</B>

renvoie Vrai si au moins un signal a été envoyé, ou Faux si une
erreur s'est produite, ou si une option illégale a été trouvée.
<DT><B>let</B> <I>argument</I> [<I>argument</I> ...]<DD>
Chaque
<I>argument</I>

est une expression arithmétique à évaluer (voir plus haut le paragraphe
<FONT SIZE="-1"><B>ÉVALUATION</B>ARITHMÉTIQUE<B>).</B>

</FONT>
Si l'évaluation du dernier
<I>argument</I>

donne 0,
<B>let</B>

renvoie 1, sinon elle renvoie 0.
<DT><B>local</B> [<I>nom</I>[=<I>valeur</I>] ...]<DD>
Pour chaque argument, on crée une variable locale ayant le
<I>nom</I>

indiqué, et à laquelle on affecte la
<I>valeur </I>

fournie. Quand
<B>local</B>

est utilisée dans une fonction, le
<I>nom</I>

de la variable n'est visible que dans la fonction, et ses descendantes.
Sans opérandes,
<B>local</B>

affiche la liste des variables locales sur la sortie standard. Il ne
faut pas utiliser 
<B>local</B>

en dehors des fonctions. La valeur de retour est 0, sauf si
<B>local</B>

est invoqué en dehors d'une fonction, ou si un
<I>nom</I>

illégal est fourni.
<DT><B>logout</B>

<DD>
Quitter un shell de login.
<DT><B>popd</B> [-<B>n</B>] [+<I>n</I>] [-<I>n</I>]<DD>
Enlève des éléments de la pile des répertoires. Sans arguments,
seul le répertoire du sommet de la pile est éliminé, et un
<B>cd</B>

est effectué en direction du nouveau répertoire au sommet.
Les arguments éventuels ont la signification suivante
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>+</B><I>n</I><DD>
supprime le <I>n</I>-ième élément de la liste affichée par
<B>dirs</B>,

en comptant depuis la gauche à partir de 0.
Par exemple : ``popd +0'' enlève le premier répertoire,
``popd +1'' le second.
<DT><B>-</B><I>n</I><DD>
supprime le <I>n</I>-ième élément de la liste affichée par
<B>dirs</B>,

en comptant depuis la droite à partir de 0.
Par exemple: ``popd -0'' supprimer le dernier répertoire,
et ``popd -1'' l'avant-dernier.
<DT><B>-n</B>

<DD>
Empêche le changement normal de répertoire lors de la suppression
d'un répertoire de la pile. On ne fait que manipuler la pile.

</DL>
<P>

Si la commande
<B>popd</B>

réussit, un
<B>dirs</B>

est effectué, et le code de retour est nul.
<B>popd</B>

renvoie Faux si une option illégale est trouvée, si la pile
de répertoires est vide, si on a indiqué un répertoire absent
de la pile, ou si le changement de répertoire a échoué.
</DL>

<DT><B>printf</B> <I>format</I> [<I>arguments</I>]<DD>
Ecrit sur la sortie standards les <I>arguments</I> fournis, sous
contrôle du <I>format</I>.
Ce <I>format</I> est une chaîne contenant trois types de caractères :
normaux, qui sont simplement copiés sur la sortie standard, les caractères
d'échappement qui sont convertis puis copiés sur la sortie standard, et les 
spécifications de format qui permettent d'afficher les
<I>argument</I>.
En plus des formats standards de <I><A HREF="/cgi-bin/man/man2html?1+printf">printf</A></I>(1), %b demande à
<B>printf</B> de développer les séquences d'échappement se trouvant dans 
l'<I>argument</I> correspondant , et %q demande l'affichage dans un
format réutilisable en entrée d'un script shell.
<P>
Le <I>format</I> est réutilisé jusqu'à consommer tous les <I>arguments</I>.
Si le <I>format</I> demande plus d'<I>arguments</I> que fournis, les
spécifications supplémentaires seront alimentées avec des valeurs nulles
ou des chaînes vides.
<DT>
<DD>
<B>pushd</B> [<B>-n</B>] [<I>rép</I>]
<DT><B>pushd</B> [<B>-n</B>] [+<I>n</I>] [-<I>n</I>]<DD>

Ajoute un répertoire au sommet de la pile des répertoires, ou
effectue une rotation dans la pile, en ramenant le répertoire
en cours au sommet. Sans argument, cette commande échange les
deux répertoires au sommet, et renvoie 0, sauf si la pile est vide.
Les arguments éventuels ont les significations suivantes :
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>+</B><I>n</I><DD>
Effectue une rotation dans la pile, de manière à amener au sommet
le <I>n</I>-ième répertoire de la liste affichée par
<B>dirs </B>

(en comptant à 
<BR>&nbsp;partir&nbsp;de&nbsp;la&nbsp;gauche).
<DT><B>-</B><I>n</I><DD>
Effectue une rotation dans la pile, de manière à amener au sommet
le <I>n</I>-ième répertoire de la liste affichée par
<B>dirs </B>

(en comptant à partir de la droite).
<DT><B>-n</B>

<DD>
Empêche le changement normal de répertoire lors d'un ajout dans
la pile. Seule la pile est manipulée.
<DT><B>rép</B>

<DD>
Ajoute le répertoire
<I>rép</I>

au sommet de la pile, et en fait 
le nouveau répertoire de travail.

</DL>
<P>

Si la commande
<B>pushd</B>

réussit, elle effectue un
<B>dirs</B>.

Si on utilise 
la première forme,
<B>pushd</B>

renvoie 0 sauf si le déplacement vers
<I>rep</I>

échoue. Avec la seconde forme,
<B>pushd</B>

renvoie 0 sauf si la pile est vide, si on a
réclamé un élément inexistant
de la pile, ou si le changement de répertoire
a échoué.
</DL>

<DT><B>pwd</B> [<B>-LP</B>]<DD>
Affiche le chemin d'accès complet au répertoire de travail actuel.
Le chemin ne contiendra pas de liens symboliques si l'option
<B>-P</B>

est fournie, ou si l'option
<B>-o physical</B>

de la commande interne
<B>set</B>

est active.
Si l'option
<B>-L</B>

est utilisée, les liens symboliques sont suivis.
Le code de retour est nul, sauf si une erreur s'est produite
durant la lecture du chemin d'accès au répertoire courant ou si
une option invalide est transmise.
<DT><B>read</B> [<B>-er</B>] [<B>-a</B> <I>nom_a</I>] [<B>-p</B> <I>msg</I>] [<I>nom</I> ...]<DD>
Une ligne est lue depuis l'entrée standard, puis le premier mot de
cette ligne est affecté au premier
<I>nom</I>,

le second mot au second
<I>nom</I>,

et ainsi de suite. Les mots restants sont affectés au
dernier
<I>nom</I>.

S'il y a moins de mots que de variables, celles restantes sont
remplies avec des valeurs vides.
Les caractères contenus dans la variables
<FONT SIZE="-1"><B>IFS</B>

</FONT>
sont utilisés comme délimiteurs de mots.
Le caractère backslash (<B>\</B>) permet de supprimer toute signification
spécial pour le caractère suivant, et autorise la continuation de lignes.
Les options éventuelles ont les significations suivantes :
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>-r</B>

<DD>
Le basckslash n'est pas un caractère d'échappement.
Il est considéré comme faisant partie de la ligne.
En particulier la paire backslash/retour-chariot ne permet pas de faire
une continuation de ligne.
<DT><B>-p</B>

<DD>
Afficher le message <I>msg</I>, sans retour-chariot final avant la lecture.
Le message n'est affiché que si la lecture a lieu
depuis un terminal.
<DT><B>-a</B>

<DD>
Les mots sont affectés aux rangs successifs d'une
variable tableau de nom
<I>nom_a</I>,

en commençant à 0.
<I>nom_a</I>

est détruit avant d'affecter de nouvelles valeurs.
Les autres <I>nom</I> sont ignorés.
<DT><B>-e</B>

<DD>
Si l'entrée standard provient d'un
terminal, la bibliothèque
<B>readline</B>

(voir
<FONT SIZE="-1"><B>READLINE</B>

</FONT>
plus bas) est utilisée pour obtenir la ligne.

</DL>
<P>

Si aucun
<I>nom</I>

n'est fourni, la ligne lue est affectée entièrement à la variable
<FONT SIZE="-1"><B>REPLY</B>.

</FONT>
Le code de retour est nul, sauf si une fin-de-fichier est rencontrée.
</DL>

<DT>
<DD>
<B>readonly</B> [<B>-afp</B>] [<I>nom</I> ...]

Les <I>noms</I> indiqués reçoivent un attribut lecture-seule.
Les valeurs affectées à ces
<I>noms</I>

ne pourront plus être modifiées.
Si l'option
<B>-f </B>

est fournie, on considère 
les fonctions correspondant 
à ces <I>noms</I>.
L'option
<B>-a</B>

restreint l'action aux variables tableaux.
Si aucun 
<I>nom</I>

n'est fourni, ou si l'option
<B>-p</B>

est utilisée, on affiche la liste des noms en lecture-seule.
L'option
<B>-p</B>

demande l'affichage dans un format susceptible d'être réutilisé en entrée.
Le code de retour est nul, sauf si une option illégale a
été trouvée, si l'un des
<I>noms</I>

n'est pas un nom légal de variables shell, ou si l'option
<B>-f</B>

est fournie avec un
<I>nom</I>

qui ne soit pas une fonction.
<DT><B>return</B> [<I>n</I>]<DD>
La fonction shell en cours d'exécution se termine en renvoyant la valeur
<I>n</I>.

Si
<I>n</I>

est omis, la valeur renvoyée est celle de la dernière commande
exécutée dans le corps de la fonction. Si cette commande est exécutée en
dehors d'une fonction, mais durant l'exécution d'un script avec la commande
<B>.</B>

(<B>source</B>) ce script s'arrête,
et la valeur renvoyée est
<I>n</I>

ou celle de la dernière commande exécutée.
Si elle est utilisée
en dehors d'une fonction ou d'un script exécuté
par <B>.</B>, le code retour est Faux.
<DT><B>set</B> [<B>--abefhkmnptuvxBCHP</B>] [<B>-o</B> <I>option</I>] [<I>arg</I> ...]<DD>
Sans options, le nom et la valeur de chacune des variables shell sont affichés
dans un format susceptible d'être réutilisé en entrée.
La sortie est triée en fonction de la localisation en cours.
Lorsque des options sont fournies, elles activent ou inhibent des attributs
du shell. Tous les arguments restant après traitement des options sont 
considérés comme des valeurs affectées dans l'ordre aux paramètres :
<B>$1</B>,

<B>$2</B>,

<B>...</B>

<B>$</B><I>n</I>.

Les options éventuelles ont les significations suivantes :
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>-a</B>

<DD>
Marquage automatique des variables modifiées ou créées pour qu'elles soient
exportées dans l'environnement des commandes exécutées ultérieurement.
<DT><B>-b</B>

<DD>
Affichage immédiat des statuts des jobs en arrière-plan qui se
terminent, plutôt que d'attendre l'affichage du prochain symbole d'accueil.
N'a d'utilité que si le contrôle des jobs est activés.
<DT><B>-e</B>

<DD>
Sortie immédiate lorsqu'une <I>commande simple</I> (voir
<FONT SIZE="-1"><B>GRAMMAIRE DU SHELL</B>

</FONT>
plus haut) se termine avec un code non nul. Le shell ne se termine
pas si la commande échoue dans une boucle
<I>until</I>

ou
<I>while</I>,

dans
un test
<I>if</I>,

dans une liste
<B>&amp;&amp;</B>

ou
<B>||</B>,

ou si le code de retour
est inversé par
<B>!</B>.

<DT><B>-f</B>

<DD>
Désactivation du développement des noms de fichiers.
<DT><B>-h</B>

<DD>
Mémorisation de l'emplacement des commandes lors de leur exécution.
Activé par défaut.
<DT><B>-k</B>

<DD>
Tous les arguments du type affectation sont placés dans l'environnement 
des commandes, pas uniquement ceux saisis avant le
nom de la commande.
<DT><B>-m</B>

<DD>
Mode supervision. Activation du contrôle des jobs. Ce mode
est actif par défaut pour les shells interactifs qui le
supportent (voir le paragraphe
<FONT SIZE="-1"><B>CONTRÔLE DES JOBS</B>

</FONT>
plus haut). Les processus en arrière-plan sont exécutés dans
des groupes de processus séparés, et une ligne indiquant leur
statuts est affichée lorsqu'ils se terminent.
<DT><B>-n</B>

<DD>
Lecture de commandes sans exécution. Ceci peut être utilisé pour
rechercher les erreurs de syntaxe dans un script. Cette option
est ignorée par les shells interactifs.
<DT><B>-o </B><I>nom__d_option</I>

<DD>
Le <I>nom_d_option</I> est l'un des suivants :
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>allexport</B>

<DD>
Identique à
<B>-a</B>.

<DT><B>braceexpand</B>

<DD>
Comme
<B>-B</B>.

<DT><B>emacs</B>

<DD>
Utiliser une interface &quot;à la emacs&quot; pour les lignes de commande. C'est
le comportement par défaut pour un shell interactif, sauf s'il est
lance avec l'option
<B>-nolineediting</B>.

<P>
<DT><B>errexit</B>

<DD>
Identique à
<B>-e</B>.

<DT><B>hashall</B>

<DD>
Comme
<B>-h</B>.

<DT><B>histexpand</B>

<DD>
Identique à
<B>-H</B>.

<DT><B>history</B>

<DD>
activer l'historique des commandes, comme décrit plus haut au paragraphe
<FONT SIZE="-1"><B>HISTORY</B>.

</FONT>
Cette option est validée par défaut pour un shell interactif.
<DT><B>ignoreeof</B>

<DD>
Identique à l'exécution d'une commande shell `IGNOREEOF=10'.
(voir le paragraphe
<B>Variables du Shell</B>

plus haut)
<DT><B>keyword</B>

<DD>
Comme
<B>-k</B>.

<DT><B>monitor</B>

<DD>
Identique à
<B>-m</B>.

<DT><B>noclobber</B>

<DD>
Identique à
<B>-C</B>.

<DT><B>noexec</B>

<DD>
Identique à
<B>-n</B>.

<DT><B>noglob</B>

<DD>
Identique à
<B>-f</B>.

<DT><B>notify</B>

<DD>
Identique à
<B>-b</B>.

<DT><B>nounset</B>

<DD>
Identique à
<B>-u</B>.

<DT><B>onecmd</B>

<DD>
Identique à
<B>-t</B>.

<DT><B>physical</B>

<DD>
Identique à
<B>-P</B>.

<DT><B>posix</B>

<DD>
Modifier le comportement de
<B>bash</B>

lorsque les opérations par défaut
s'éloigne de Posix 1003.2 afin d'être conforme au standard.
<DT><B>privileged</B>

<DD>
Identique à
<B>-p</B>.

<DT><B>verbose</B>

<DD>
Identique à
<B>-v</B>.

<DT><B>vi</B>

<DD>
Utiliser une interface d'édition des lignes de commande &quot;à la vi&quot;.
<DT><B>xtrace</B>

<DD>
Identique à
<B>-x</B>.

<P>
</DL>
<P>

Si
<B>-o</B>

est invoqué sans <I>nom_d_option</I>, les valeurs actuelles des
options sont affichées.
Si
<B>+o</B>

est fourni sans <I>nom_d_option</I>, la série de commande
<B>set</B>

permettant de recréer la configuration courante est affichée
sur la sortie standard.
</DL>

<DT><B>-p</B>

<DD>
Basculer en mode
<I>privilégié</I>.

Dans ce mode, le fichier
<B>$ENV</B>

et
<B>$BASH_ENV</B>

ne sont pas traités, les fonctions shells ne sont pas héritées de
l'environnement, et la variable <B>SHELLOPTS</B>, si elle est dans 
l'environnement, est ignorée.
Si le shell démarre avec un UID (resp. GID) effectif différent de son
UID (GID) réel, et si l'option <B>-p</B> n'est pas fournie, ce comportement
est appliqué, et l'UID (GID) effectif reprend la valeur de l'UID (GID) réel.
Si l'option <B>-p</B> est fournie au démarrage l'UID (GID) effectif n'est
pas modifié.
Désactiver cette option force la réinitialisation des UID et GID effectifs
à la valeur des UID et GID réels.
<DT><B>-t</B>

<DD>
Sortie automatique après lecture et exécution d'une commande.
<DT><B>-u</B>

<DD>
Considérer les variables inexistantes comme des erreurs durant
l'expansion des paramètres. Si on tente de développer une variable
inexistante, le shell affiche un message d'erreur, et, s'il n'est
pas interactif, se termine avec un code de retour non-nul.
<DT><B>-v</B>

<DD>
Affichage des lignes de commandes au fur et à mesure de leur lecture.
<DT><B>-x</B>

<DD>
Après l'expansion de chaque <I>commande simple</I>, <B>bash</B>
affiche la valeur de
<FONT SIZE="-1"><B>PS4</B>,

</FONT>
suivie par la commande et ses arguments développés.
<DT><B>-B</B>

<DD>
Le shell effectue l'expansion des
accolades (voir plus haut)
Cette opriont est active par défaut.
<DT><B>-C</B>

<DD>
Avec cette option,
<B>bash</B>

n'écrasera pas un fichier existant avec les opérateurs
<B>&gt;</B>,

<B>&gt;&amp;</B>,

et
<B>&lt;&gt;</B>.

Ce comportement peut être surchargé lors de la création d'un fichier
de sortie en utilisant l'opérateur de redirection
<B>&gt;|</B>

à la place de
<B>&gt;</B>.

<DT><B>-H</B>

<DD>
Autoriser le style
<B>!</B>

de substitution historique. C'est le comportement par défaut lorsque le
shell est interactif.
<DT><B>-P</B>

<DD>
Ne pas suivre les liens symboliques
lors d'une commande comme
<B>cd</B>

qui modifie le répertoire de travail. Utiliser à la place le
répertoire physique. Par défaut
<B>bash</B>

suit la chaîne logique des répertoires lors des commandes
qui modifient le répertoire en cours.
<DT><B>--</B>

<DD>
Si aucun argument ne suit ce drapeau, alors les paramètres positionnels
sont détruits. Sinon, les paramètres positionnels sont remplis avec les
<I>arguments</I>, même si certains d'entre eux commencent par un
<B>-</B>.

<DT><B>-</B>

<DD>
Fin des options. Tous les <I>arguments</I> restants sont affectés aux paramètres
positionnels. Les attributs
<B>-x</B>

et
<B>-v</B>

sont désactivés.
S'il n'y a pas d'<I>arguments</I>, les paramètres positionnels ne sont pas
modifiés.

</DL>
<P>

Par défaut les attributs sont désactivés, sauf indication contraire.
En utilisant + à la place de - on désactive explicitement un drapeau.
Les attributs peuvent également être fournis en argument lors de 
l'invocation du shell. Le jeu de drapeaux actuellement actifs est disponible
dans
<B>$-</B>.

La valeur de retour est vraie sauf si une option invalide est rencontrée.
</DL>

<DT><B>shift</B> [<I>n</I>]<DD>
Les paramètres positionnels à partir de <I>n</I>+1 ... sont renommés en
<B>$1</B>

<B>....</B>

Les paramètres représentés par les nombres <B>$#</B> jusqu'à <B>$#</B>-<I>n</I>+1
sont supprimés.
<I>n</I>

doit être un entier non-négatif inférieur ou égal à <B>$#</B>.
Si
<I>n</I>

vaut 0, aucun paramètres n'est modifié.
Si
<I>n </I>

est omis, on suppose qu'il vaut 1.
Si
<I>n</I>

est supérieur à <B>$#</B>, les paramètres positionnels ne sont pas modifiés.
Le code de retour est supérieur à 0 si
<I>n</I>

est supérieur à
<B>$#</B>

ou inférieur à 0. Sinon le code de retour est nul.
<DT><B>shopt</B> [<B>-pqsu</B>] [<B>-o</B>] [<I>nom_opt</I> ...]<DD>
Bascule la valeur des variables contrôlant le comportement optionnel du shell.
Sans option, ou avec l'option
<B>-p</B>,

une liste de toutes les options configurables est affichée, avec l'indication
de l'état de chacune d'entre elles.
L'option <B>-p</B> réclame un affichage susceptible d'être réutilisé
en entrée.
Les autres options ont les significations suivantes :
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>-s</B>

<DD>
Activer chaque <I>nom_opt</I> indiqué.
<DT><B>-u</B>

<DD>
Désactiver chaque <I>nom_opt</I> indiqué.
<DT><B>-q</B>

<DD>
Supprimer la sortie normale (mode silencieux). Le code de retour indique si
l'option <I>nom_opt</I> est active ou non.
Si plusieurs <I>nom_opt</I> sont fournis en argument de l'option
<B>-q</B>,

le code de retour est nul si tous les <I>nom_opt</I> sont actifs,
et non-nul sinon.
<DT><B>-o</B>

<DD>
Restreindre les valeurs des <I>nom_opts</I> à celles définies pour l'option
<B>-o</B>

de la commande
<B>set</B>

interne.

</DL>
<P>

Si l'option
<B>-s</B>

ou
<B>-u</B>

est utilisé sans argument <I>nom_opt</I>, l'affichage est limité aux options
qui sont actives ou inactives, respectivement.
sauf indication contraire, les options <B>shopt</B> sont désactivés par
défaut.
<P>

Le code de retour lors d'un affichage est zéro si tous les <I>nom_opt</I>
sont actifs, non-nul sinon. Lors d'une activation ou inhibition, le code
de retour est nul sauf si <I>nom_opt</I> n'est pas une option valide
du shell.
<P>

La liste des options <B>shopt</B> est :

<P>


<DL COMPACT>
<DT><B>cdable_vars</B>

<DD>
Si cette option est active, un argument de la commande interne
<B>cd</B>

qui n'est pas un répertoire est
supposé être un nom de variable dont la valeur est le répertoire
visé.
<DT><B>cdspell</B>

<DD>
Les erreurs minimes de frappe dans un composant du répertoire en argument de
la commande
<B>cd</B>

seront corrigées. Les erreurs corrigées sont les inversions d'un caractère,
un caractère manquant et un caractère en trop.
Si une correction est possible, le nom de répertoire corrigé est affiché,
et la commande est exécuté.
Cette option n'est utilisé que par les shells interactifs.
<DT><B>checkhash</B>

<DD>
<B>bash</B> vérifiera si une commande trouvée dans la table de hachage existe
avant d'essayer de l'exécuter. Si une commande hachée n'existe plus, la
recherche normale de chemin est assurée.
<DT><B>checkwinsize</B>

<DD>
<B>bash</B> vérifiera la taille de la fenêtre après chaque commande
et, au besoin, mettra à jour les valeurs des variables
<FONT SIZE="-1"><B>LINES</B>

</FONT>
et
<FONT SIZE="-1"><B>COLUMNS</B>.

</FONT>
<DT><B>cmdhist</B>

<DD>
Lorsque cette option est active,
<B>bash</B>

essaiera de sauvegarder les commandes s'étendant sur plusieurs
lignes en une seule entrée d'historique. Ceci facilite
l'édition ultérieure de commandes multilignes.
<DT><B>dotglob</B>

<DD>
Si cette option est active,
<B>bash</B>

inclut les noms de fichiers commençant par un `.' dans les résultats
des développements de noms de fichiers.
<DT><B>execfail</B>

<DD>
Un shell non-interactif ne se terminera pas s'il ne peut exécuter
un fichier fourni en argument de la commande interne
<B>exec</B>.

Un shell interactif ne se termine pas si
<B>exec</B>

échoue.
<DT><B>expand_aliases</B>

<DD>
Les alias sont développés comme décrit plus haut, au paragraphe
<FONT SIZE="-1"><B>ALIASES</B>.

</FONT>
Cette option est activée par défaut pour les shells interactifs.
<DT><B>extglob</B>

<DD>
Les fonctionnalités étendues de mise en correspondance décrite au paragraphe
<B>Développement des noms de fichiers</B> sont activées.
<DT><B>histappend</B>

<DD>
La liste d'historique est ajoutée au fichier dont le nom est contenu
dans la variable
<B>HISTFILE</B>

lorsque le shell se termine, plutôt que d'écraser ce fichier.
<DT><B>histreedit</B>

<DD>
Si la bibliothèque
<B>readline</B>

est en service, un utilisateur peut ré-éditer une substitution
d'historique qui a échoué.
<DT><B>histverify</B>

<DD>
Si la bibliothèque
<B>readline</B>

est en service, le résultat de la substitution d'historique n'est pas transmise
immédiatement au shell. A la place, la ligne résultant est chargée dans le
tampon d'édition de <B>readline</B> permettant des modifications ultérieures.
<DT><B>hostcomplete</B>

<DD>
Si la bibliothèque
<B>readline</B>

est en service, <B>bash</B> essayera d'assurer la complétion des noms d'hôtes
lorsqu'un mot contient un <B>@</B> (voir
<B>Completion</B>

au paragraphe
<FONT SIZE="-1"><B>READLINE</B>

</FONT>
plus haut).
Cette option est active par défaut.
<DT><B>huponexit</B>

<DD>
<B>bash</B> enverra un signal
<FONT SIZE="-1"><B>SIGHUP</B>

</FONT>
à tous les jobs lorsqu'un shell de login interactif se termine.
<DT><B>interactive_comments</B>

<DD>
Un mot commençant par un
<B>#</B>

autorisera tous les autres caractères de la ligne à être ignorés
dans un shell interactif (voir le paragraphe
<FONT SIZE="-1"><B>COMMENTAIRES</B>

</FONT>
plus haut). Cette option est active par défaut.
<DT><B>lithist</B>

<DD>
Si cette option, et l'option
<B>cmdhist</B>

sont actives, les commandes multilignes sont sauvées dans l'historique
avec des sauts-de-ligne imbriqués plutôt que des points-virgules.
<DT><B>mailwarn</B>

<DD>
Si cette option est active et si un fichier que <B>bash</B> surveille pour les
mails a été accédé depuis la dernière vérification, le message &quot;The mail
in <I>fichier</I> has been read&quot; est affiché.
<DT><B>nocaseglob</B>

<DD>
Si cette option est active,
<B>bash</B>

traite les noms de fichiers sans différences minuscules/majuscules lors
du développement des noms de fichiers
(voir plus
haut).
<DT><B>nullglob</B>

<DD>
Si cette option est active,
<B>bash</B>

autorise les motifs ne correspondant à aucun fichiers
(voir
<B>Développement des noms de fichiers</B>

plus haut)
à se développer en une chaîne nulle plutôt qu'en une valeur littérale.
<DT><B>promptvars</B>

<DD>
If set, prompt strings undergo variable and parameter expansion after
being expanded as described in
<FONT SIZE="-1"><B>PROMPTING</B>

</FONT>
above.  This option is enabled by default.
<DT><B>restricted_shell</B>

<DD>
Le shell active cette option s'il est démarré en mode restreint (voir
<FONT SIZE="-1"><B>SHELL RESTREINT</B>

</FONT>
plus bas).
Cette valeur ne peut pas être changée.
Elle n'est pas réinitialisée lorsque les fichiers de démarrage sont exécutés,
ce qui permet à ces fichiers de découvrir si un shell est resteint ou non.
<DT><B>shift_verbose</B>

<DD>
La commande interne
<B>shift</B>

affiche un message d'erreur lorsque le nombre de décalage dépasse le
nombre de paramètres positionnels.
<DT><B>sourcepath</B>

<DD>
La commande interne
<B>source</B> (<B>.</B>) utilise la valeur de la variable
<FONT SIZE="-1"><B>PATH</B>

</FONT>
pour trouver le répertoire contenant le fichier fourni en argument.
Cette option est active par défaut.
</DL>
</DL>

<DT><B>suspend</B> [<B>-f</B>]<DD>
Suspend l'exécution du shell jusqu'à la réception d'un signal
<FONT SIZE="-1"><B>SIGCONT</B>.

</FONT>
L'option
<B>-f</B>

élimine le message d'erreur s'il s'agit d'un shell de login, et
force sa suspension. Le code de retour est nul sauf si l'on utilise
un shell de login et si l'option
<B>-f</B>

n'est pas fournie, ou si le contrôle des jobs n'est pas disponible.
<DT>
<DD>
<B>test</B> <I>expr</I>
<DT><B>[</B> <I>expr</I> <B>]</B><DD>
Renvoie la valeur 0 (vrai) ou 1 (faux) en fonction de l'évaluation
de l'expression conditionnelle
<I>expr</I>.

Chaque opérateur et opérande doit être représenté par un argument distinct.
Les expressions sont composées des unités élémentaires décrites plus haut dans
<FONT SIZE="-1"><B>EXPRESSIONS</B>CONDITIONNELLES

</FONT>

<P>

Les expressions peuvent être combinées avec les opérateurs suivant, par
ordre de précédence décroissante :
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>! </B><I>expr</I>

<DD>
Vrai si
<I>expr</I>

est fausse
<DT><B>( </B><I>expr</I> )

<DD>
Renvoie la valeur de <I>expr</I>.
Peut servir à surcharger la précédence normale des opérateurs.
<DT><I>expr1</I> -<B>a</B> <I>expr2</I><DD>
Vrai si
<I>expr1</I>

et
<I>expr2</I>

sont toutes deux vraies.
<DT><I>expr1</I> -<B>o</B> <I>expr2</I><DD>
Vrai si
<I>expr1</I>

ou
<I>expr2</I>

est vraie.

</DL>
<P>

<B>test</B> et <B>[</B> évaluent les expresssions conditionnelles en fonction
d'un jeu de règles dépendant du nombre d'arguments.

<P>


<DL COMPACT>
<DT>0 argument<DD>
L'expression est fausse
<DT>1 argument<DD>
L'expression est vraie si et seulement si l'argument est non nul.
<DT>2 arguments<DD>
Si le premier argument est <B>!</B>, l'expression est vraie si et seulement
si le second argument est nul.
Si le premier argument est l'un des opérateurs conditionnel unaires décrits
plus haut au paragraphe
<FONT SIZE="-1"><B>EXPRESSIONS</B>CONDITIONNELLES

</FONT>
l'expression est vraie si le test unaire est vrai.
Si le premier argument n'est pas un opérateur conditionnel unaire; l'expression
est fausse.
<DT>3 arguments<DD>
Si le second argument est l'un des opérateur conditionnels binaires décrits
plus haut au paragraphe
<FONT SIZE="-1"><B>EXPRESSIONS</B>CONDITIONNELLES<B>,</B>

</FONT>
le résultat de l'expression est le résultat du test binaire utilisant le
premier et le troisième argument en tant qu'opérandes.<TT>&nbsp;&nbsp;</TT><BR>
Si le premier argument est <B>!</B>, la valeur est la négation du test binaire
utilisant les deuxième et troisième arguments.
Si le premier argument est exactement <B>(</B> et le troisième argument est
exactement <B>)</B>, le résultat est le test unaire du second 
argument.
Sinon l'expression est fausse.
Les opérateurs <B>-a</B> et <B>-o</B> sont considérés comme des opérateurs
binaires dans ce cas.
<DT>4 arguments<DD>
Si le premier argument est <B>!</B>, le résultat est la négation de l'expression
à trois arguments composée des arguments restants.
Sinon l'expression est analysée et évaluée selon les règles de précédence
décrites ci-dessus.
<DT>5 argument ou plus.<DD>
L'expression est analysée et évaluée selon les règles de précédence
décrites ci-dessus.
</DL>
</DL>


<DT><B>times</B>

<DD>
Affiche les durées cumulées utilisateur et système pour le shell
et les processus lancés par ce shell. Le code de retour est nul.
<DT><B>trap</B> [<B>-lp</B>] [<I>cmd</I>] [<I>sigspec</I>]<DD>
La commande
<I>cmd</I>

sera lue et exécutée lorsque le shell recevra l'un des 
signaux
<I>sigspec</I>.

Si
<I>cmd</I>

est absent ou si elle vaut
<B>-</B>,

tous les signaux indiqués reprennent 
leurs comportements originaux
(qu'ils avaient au démarrage du shell).
Si
<I>cmd</I>

est une chaîne nulle, les signaux
<I>sigspec</I>

seront ignorés par le shell et par les commandes qu'il invoque.
Si
<I>cmd</I>

est
<B>-p</B>

alors le comportement pour chacun
des
<I>sigspec</I>

est affiché. Si aucun argument n'est fourni, ou si 
l'option
<B>-p</B>

est seule,
<B>trap</B>

affiche les commandes associées avec chaque signaux.
Les signaux
<I>sigspec</I>

peuvent être spécifié en indiquant des noms de signaux définis dans
&lt;<I>signal.h</I>&gt;, ou les numéros des signaux. 
Si
<I>sigspec</I>

vaut
<FONT SIZE="-1"><B>EXIT</B>

</FONT>
(0) la commande
<I>cmd</I>

sera exécutée au moment de quitter le shell. Si
<I>sigspec</I>

est
<FONT SIZE="-1"><B>DEBUG</B>,

</FONT>
la commande
<I>cmd</I>

sera exécutée après chaque <I>commande simple</I> (voir
<FONT SIZE="-1"><B>GRAMMAIRE DU SHELL</B>

</FONT>
plus haut).
L'option
<B>-l</B>

affiche la liste des noms de signaux, 
et leurs numéros correspondants.
Les signaux ignorés lors de l'invocation du shell ne peuvent pas être
capturés ni reprendre leurs comportements par défaut.
Lors de la création d'un processus fils, les signaux capturés reprennent
leur comportement par défaut. Le code de retour est faux si un nom ou un
numéro de signal
est invalide, sinon
<B>trap</B>

renvoie une valeur vraie.
<DT><B>type</B> [<B>-atp</B>] <I>nom</I> [<I>nom</I> ...]<DD>
sans option, indique
comment chaque
<I>nom</I>

doit être interprété si on l'utilise en nom de commande.
Si l'attribut
<B>-t</B>

est utilisé,
<B>type</B>

affiche une des phrases suivantes
<I>alias</I>,

<I>keyword</I>,

<I>function</I>,

<I>builtin</I>,

ou
<I>file </I>

selon que le
<I>nom</I>

est un alias, un mot-clé réservé au shell, une fonction, une commande
interne, ou un fichier sur le disque.
Si le
<I>nom</I>

n'est pas trouvé, rien n'est affiché et le code de retour
est faux.
Si l'argument
<B>-p</B>

est utilisé,
<B>type</B>

renvoie le nom du fichier
qui sera exécuté si l'on tape le
<I>nom</I>

en guise de commande,
ou rien si <TT>type -t name</TT>
ne renverrait pas
<I>file</I>.

Si une commande est disponible dans la table de hachage,
<B>-p</B>

affiche la valeur de cette table, qui n'est pas nécessairement le
fichier apparaissant en premier dans le
<FONT SIZE="-1"><B>PATH</B>.

</FONT>
Si l'option
<B>-a</B>

est invoquée,
<B>type</B>

affiche tous les emplacements contenant un exécutable du
<I>nom</I>

indiqué.
Ceci inclut les alias et les fonctions,
sauf si l'option
<B>-p</B>

est également présente.
La table de hachage des commandes n'est pas consultée
avec l'option
<B>-a</B>.

<B>type</B>

renvoie vrai si l'un des arguments est trouvé, et faux si
aucun n'a été trouvé.
<DT><B>ulimit</B> [<B>-SHacdflmnpstuv</B> [<I>limite</I>]]<DD>
fournit, sur les systèmes qui le permettent, un mécanisme de contrôle 
des ressources disponibles pour le shell et pour les processus qu'il
lance. La valeur de la
<I>limite</I>

peut être un nombre (utilisant les unités particulières de la ressources), ou
la valeur
<B>unlimited</B>.

Les options <B>H</B> et <B>S</B> précisent si la limite doit être dure (Hard),
ou souple (Soft). Une limite dure ne peut pas être augmentée une fois qu'elle
a été positionnée. Une limite souple peut être augmentée jusqu'à la hauteur de
la limite dure correspondante.
Par défaut, les limites fixées sont souples.
Si la
<I>limite</I>

est omise, on affiche la valeur de la limite souple pour la ressource
indiquée, sauf si l'option <B>H</B> est fournie. Quand plusieurs ressources
sont indiquées, leurs noms, et leurs unités respectives sont affichés
avant les valeurs. Les options sont interprétées ainsi :
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT><B>-a</B>

<DD>
affichage de toutes les limites actuelles
<DT><B>-c</B>

<DD>
la taille maximale pour la création d'un fichier core
<DT><B>-d</B>

<DD>
la taille maximale du segment de données d'un processus
<DT><B>-f</B>

<DD>
la taille maximale d'un fichier créé par le shell
<DT><B>-l</B>

<DD>
la taille maximale que l'on peut verrouiller en mémoire
<DT><B>-m</B>

<DD>
la taille maximale de la partie résidente d'un processus
<DT><B>-n</B>

<DD>
le nombre maximal de descripteurs de fichiers ouverts (la plupart des systèmes
ne permettent pas de modification)
<DT><B>-p</B>

<DD>
La taille d'un tuyau (pipe) en blocs de 512 octets (parfois non modifiable)
<DT><B>-s</B>

<DD>
la taille maximale de la pile
<DT><B>-t</B>

<DD>
la durée maximale, en seconde, de temps CPU accordé à un processus.
<DT><B>-u</B>

<DD>
le nombre maximal de processus autorisés pour un seul utilisateur
<DT><B>-v</B>

<DD>
la quantité de mémoire virtuelle disponible pour le shell

</DL>
<P>

Si une
<I>limite</I>

est fournie, la ressource correspondante recevra cette limite (l'option
<B>-a</B>

ne permet que l'affichage).
Si aucune option n'est indiquée, la ressource
<B>-f</B>

est prise par défaut. Les valeurs s'expriment en kilo-octets, sauf pour
<B>-t</B>,

ou elles s'expriment en secondes,
<B>-p</B>,

qui utilise des unités de blocs de 512 octets,
ainsi que
<B>-n</B>

et
<B>-u</B>,

qui n'ont pas d'unités. La valeur renvoyée est 0 sauf si une option
illégale est détectée, si un argument non-numérique autre que
<B>unlimited</B> est fourni comme <I>limite</I>, ou si une erreur
se produit durant la modification de la limite.
</DL>

<DT><B>umask</B> [<B>-p</B>] [<B>-S</B>] [<I>mode</I>]<DD>
Le masque de création de fichier de l'utilisateur est fixé au
<I>mode </I>

indiqué.
Si
<I>mode</I>

commence par un chiffre, il est interprété comme un nombre octal,
sinon il est considéré comme un masque symbolique, semblable à
ceux acceptes par
<I><A HREF="/cgi-bin/man/man2html?1+chmod">chmod</A></I>(1).

Si
<I>mode</I>

est omis, ou si l'option
<B>-S</B>

est fournie, la valeur courante
du masque est affichée.
L'option
<B>-S</B>

affiche le masque sous forme symbolique, l'affichage par défaut
étant en octal.
Si l'option
<B>-p</B>

est fournie, et si le
<I>mode</I>

est omis, la sortie a lieu dans un format réutilisable en entrée.
Le code de retour est nul si le mode a pu être changé correctement,
ou si on a omis l'argument <I>mode</I>, et faux sinon.
<DT><B>unalias</B> [-<B>a</B>] [<I>nom</I> ...]<DD>
Supprime le <I>nom</I> de la liste des alias définis. Si l'option
<B>-a</B>

est demandée, toutes les définitions d'alias sont supprimées. La
valeur renvoyée est vraie sauf si un
<I>nom</I>

mentionné n'est pas un alias défini.
<DT><B>unset</B> [-<B>fv</B>] [<I>nom</I> ...]<DD>
Pour chaque
<I>nom</I>

indiqué, supprimer la variable ou la fonction correspondante.
Si aucune option n'est fournie, ou si l'option
<B>-v</B>

est demandée, chaque
<I>nom</I>

se réfère à une variable shell.
Les variables en lecture-seule ne peuvent pas être détruites.
Si l'option
<B>-f</B>

est indiquée, 
chaque
<I>nom</I>

se réfère à une fonction shell, et la définition de la fonction
est supprimée.
Chaque variable ou fonction est supprimé de l'environnement transmis
aux commandes ultérieures.
Si l'une des variables
<FONT SIZE="-1"><B>RANDOM</B>,

</FONT>
<FONT SIZE="-1"><B>SECONDS</B>,

</FONT>
<FONT SIZE="-1"><B>LINENO</B>,

</FONT>
<FONT SIZE="-1"><B>HISTCMD</B>,

</FONT>
ou
<FONT SIZE="-1"><B>DIRSTACK</B>

</FONT>
est supprimée, elle perd ses propriétés spécifiques, même s'il elle
est recréée ultérieurement. Le code de retour est vrai, à moins qu'un des 
<I>noms</I>

n'existe pas, ou ne soit pas supprimable.
<DT><B>wait</B> [<I>n</I>]<DD>
Attend que le processus indique se termine, et renvoie son code de
retour.
<I>n</I>

peut indiquer un PID, ou un job. S'il s'agit d'un indicateur de job, on attendra
la fin de tous les processus du tube de ce job.
Si
<I>n</I>

est omis, on attend la fin de tous les processus fils actuellement actifs, et
le code de retour sera zéro. Si
<I>n</I>

se rapporte à un processus ou un job inexistant, le code de retour sera 127.
Dans tous les autres cas, le code de retour sera celui du dernier processus
ou job attendu.


</DL>
<A NAME="lbCW">&nbsp;</A>
<H2>SHELL RESTREINT</H2>

<P>

Si
<B>bash</B>

démarre sous le nom
<B>rbash</B>,

ou si l'option
<B>-r</B>

est fournie lors de son invocation,
le shell devient restreint.
Un shell restreint permet de configurer un
environnement plus contrôlé qu'un shell standard.
Il se comporte de même manière que
<B>bash</B>

à la différence des actions suivantes qui sont désactivées ou non réalisées :
<DL COMPACT>
<DT>&bull;<DD>
changer de répertoire avec <B>cd</B> ;
<DT>&bull;<DD>
modifier ou détruire les valeurs de
<B>SHELL</B>,

<B>PATH</B>,

<B>ENV</B>,

ou
<B>BASH_ENV</B> ;

<DT>&bull;<DD>
indiquer des noms de commandes contenant un
<B>/</B> ;

<DT>&bull;<DD>
indiquer un nom de fichier contenant un
<B>/</B>

comme argument de la commande
<B>.</B>

interne ;
<DT>&bull;<DD>
importer une définition de fonction dans l'environnement au démarrage ;
<DT>&bull;<DD>
analyser les valeurs de <B>SHELLOPTS</B> au démarrage ;
<DT>&bull;<DD>
rediriger la sortie en utilisant un opérateur &gt;, &gt;|, &lt;&gt;, &gt;&amp;, &amp;&gt;, et &gt;&gt; &quot; ;&quot;
<DT>&bull;<DD>
utiliser la commande interne
<B>exec</B>

pour remplacer le shell par une autre commande &quot; ;&quot;
<DT>&bull;<DD>
ajouter ou supprimer des commandes internes avec les options
<B>-f</B>

et 
<B>-d</B>

de la commande
<B>enable</B>

interne ;
<DT>&bull;<DD>
indiquer l'option
<B>-p</B>

de la commande
<B>command</B>

interne ;
<DT>&bull;<DD>
supprimer le mode restreint avec
<B>set +r</B> ou <B>set +o restricted</B>.
</DL>
<P>

Ces restrictions sont mises en place après la lecture des fichiers de démarrage.
<P>

Lorsqu'ue commande trouvée dans un script shell est exécutée (voir le paragraphe
<FONT SIZE="-1"><B>EXECUTION DES COMMANDES</B>

</FONT>
plus haut),
<B>rbash</B>

supprime les restrictions dans le shell servant a exécuter le
script.
<A NAME="lbCX">&nbsp;</A>
<H2>VOIR AUSSI</H2>


<DL COMPACT>
<DT><I>Bash Features</I>, Brian Fox et Chet Ramey<DD>
<DT><I>The Gnu Readline Library</I>, Brian Fox et Chet Ramey<DD>
<DT><I>The Gnu History Library</I>, Brian Fox et Chet Ramey<DD>
<DT><I>Portable Operating System Interface (POSIX) Part 2: Shell and Utilities</I>, IEEE<DD>
<DT><I><A HREF="/cgi-bin/man/man2html?1+sh">sh</A></I>(1), <I><A HREF="/cgi-bin/man/man2html?1+ksh">ksh</A></I>(1), <I><A HREF="/cgi-bin/man/man2html?1+csh">csh</A></I>(1)<DD>
<DT><I><A HREF="/cgi-bin/man/man2html?1+emacs">emacs</A></I>(1), <I><A HREF="/cgi-bin/man/man2html?1+vi">vi</A></I>(1)<DD>
<DT><I><A HREF="/cgi-bin/man/man2html?3+readline">readline</A></I>(3)<DD>

</DL>
<A NAME="lbCY">&nbsp;</A>
<H2>FICHIERS</H2>


<DL COMPACT>
<DT>
<I>/bin/bash2</I>

<DD>
L'exécutable <B>bash</B>.
<DT>
<I>/etc/profile</I>

<DD>
Le fichier d'initialisation globale, exécutée par les shells de login.
<DT>
<I>~/.bash_profile</I>

<DD>
Le fichier d'initialisation personnalisée, exécutée par les shells de login.
<DT>
<I>~/.bashrc</I>

<DD>
Le fichier de démarrage personnel, pour les shells interactifs.
<DT>
<I>~/.bash_logout</I>

<DD>
Le fichier de sortie des shells de login lors de la déconnexion.
<DT>
<I>~/.inputrc</I>

<DD>
Le fichier d'initialisation personnalisée de <I>readline</I>.

</DL>
<A NAME="lbCZ">&nbsp;</A>
<H2>AUTEURS</H2>

Brian Fox, Free Software Foundation (auteur principal)
<BR>

<A HREF="mailto:bfox@ai.MIT.Edu">bfox@ai.MIT.Edu</A>
<P>

Chet Ramey, Case Western Reserve University
<BR>

<A HREF="mailto:chet@ins.CWRU.Edu">chet@ins.CWRU.Edu</A>
<A NAME="lbDA">&nbsp;</A>
<H2>RAPPORT DE BOGUE</H2>

Si vous trouvez un bogue dans
<B>bash,</B>

vous êtes encouragés à nous en faire part. Tout d'abord vous devez
vous assurer qu'il s'agit réellement d'un dysfonctionnement, et
qu'il apparaît bien dans la dernière version de
<B>bash</B>

disponible.
<P>

Une fois que vous êtes sûrs qu'il s'agit bien d'un bogue, utilisez la commande
<I>bashbug</I>

pour nous envoyer un rapport.
Si vous avez trouvé une correction, n'hésitez pas à l'envoyer en même temps.
Les simples suggestions, ou les remarques d'ordre `philosophique' peuvent
être transmises à bug-bash@<I>prep.ai.MIT.Edu</I> ou postées dans le
groupe Usenet
<B>gnu.bash.bug</B>.

<P>

TOUS les rapports de bogue doivent contenir :
<P>


<DL COMPACT>
<DT>Le numéro de version de <B>bash</B><DD>
<DT>Le matériel et le système d'exploitation utilisés<DD>
<DT>La version du compilateur utilisé pour compiler <B>bash</B>.<DD>
<DT>Une description du comportement du bogue. [NDT : En anglais évidemment]<DD>
<DT>Un petit script, ou une manipulation qui met en évidence le bogue.<DD>

</DL>
<P>

<I>bashbug</I>

insère automatiquement les trois premiers éléments de cette
liste dans le formulaire qu'il fournit pour remplir le rapport de bogue.
<P>

Les commentaires et rapports d'erreurs concernant la version
originale de cette page de manuel doivent être transmis à
<I><A HREF="mailto:chet@ins.CWRU.Edu">chet@ins.CWRU.Edu</A></I>.

Ceux concernant la version française peuvent être envoyés à
<I><A HREF="mailto:ccb@club-internet.fr">ccb@club-internet.fr</A></I>.

<A NAME="lbDB">&nbsp;</A>
<H2>BOGUES</H2>

<P>

Cet interpréteur est volumineux et lent.
<P>

Il y a quelques différences subtiles de comportement entre
<B>bash</B>

et les versions traditionnelles de
<B>sh</B>,

principalement à cause des spécifications
<FONT SIZE="-1"><B>POSIX</B>.

</FONT>
<P>

L'utilisation des alias peut avoir des conséquences inattendues.
<P>

Les commandes et les fonctions internes ne peuvent pas être arrétées/relancées.
<P>

Les séquences de commandes de la forme `a ; b ; c' ne sont pas gérées
proprement lors d'une interruption de processus.
En cas de suspension d'une telle séquence, l'interpréteur exécute immédiatement 
la commande suivante de la séquence. 
Il suffit de placer cette séquence entre parenthèses pour la forcer à créer un 
sous-shell, qui, lui, sera interruptible
en bloc.
<P>

Les commandes à l'intérieur de <B>$(</B>...<B>)</B> ne sont pas analysées avant 
la réalisation de la complétion. Cela peut retarder l'affichage de messages
d'erreurs pendant un certain temps après la frappe de la commande.
<P>

Les variables de type tableau ne peuvent pas (encore) être exportées.

<A NAME="lbDC">&nbsp;</A>
<H2>TRADUCTION</H2>

Christophe Blaess 1997-2003.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NOM</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">COPYRIGHT</A><DD>
<DT><A HREF="#lbAE">DESCRIPTION</A><DD>
<DT><A HREF="#lbAF">OPTIONS</A><DD>
<DT><A HREF="#lbAG">ARGUMENTS</A><DD>
<DT><A HREF="#lbAH">INVOCATION</A><DD>
<DT><A HREF="#lbAI">DÉFINITIONS</A><DD>
<DT><A HREF="#lbAJ">MOTS RÉSERVÉS</A><DD>
<DT><A HREF="#lbAK">GRAMMAIRE DU SHELL</A><DD>
<DL>
<DT><A HREF="#lbAL">Commandes simples</A><DD>
<DT><A HREF="#lbAM">Pipelines</A><DD>
<DT><A HREF="#lbAN">Listes</A><DD>
<DT><A HREF="#lbAO">Commandes composées</A><DD>
</DL>
<DT><A HREF="#lbAP">COMMENTAIRES</A><DD>
<DT><A HREF="#lbAQ">PROTECTION</A><DD>
<DT><A HREF="#lbAR">PARAMÈTRES</A><DD>
<DL>
<DT><A HREF="#lbAS">Paramètres Positionnels</A><DD>
<DT><A HREF="#lbAT">Paramètres Spéciaux</A><DD>
<DT><A HREF="#lbAU">Variables du Shell</A><DD>
<DT><A HREF="#lbAV">Tableaux</A><DD>
</DL>
<DT><A HREF="#lbAW">EXPANSION</A><DD>
<DL>
<DT><A HREF="#lbAX">Expansion des accolades</A><DD>
<DT><A HREF="#lbAY">Développement du Tilde</A><DD>
<DT><A HREF="#lbAZ">Remplacement des paramètres</A><DD>
<DT><A HREF="#lbBA">Substitution de commandes</A><DD>
<DT><A HREF="#lbBB">Évaluation Arithmétique</A><DD>
<DT><A HREF="#lbBC">Substitution de Processus</A><DD>
<DT><A HREF="#lbBD">Séparation des mots</A><DD>
<DT><A HREF="#lbBE">Développement des noms de fichiers</A><DD>
<DT><A HREF="#lbBF">Suppression des protections</A><DD>
</DL>
<DT><A HREF="#lbBG">REDIRECTION</A><DD>
<DL>
<DT><A HREF="#lbBH">Redirection d'entrée</A><DD>
<DT><A HREF="#lbBI">Redirection de sortie</A><DD>
<DT><A HREF="#lbBJ">Redirection pour Ajout en Sortie</A><DD>
<DT><A HREF="#lbBK">Redirection de la sortie standard et de la sortie d'erreur</A><DD>
<DT><A HREF="#lbBL">Document en ligne</A><DD>
<DT><A HREF="#lbBM">Dédoublement de descripteur de fichier</A><DD>
<DT><A HREF="#lbBN">Ouverture en Lecture/Écriture d'un descripteur de fichier</A><DD>
</DL>
<DT><A HREF="#lbBO">ALIAS</A><DD>
<DT><A HREF="#lbBP">FONCTIONS</A><DD>
<DT><A HREF="#lbBQ">CALCUL ARITHMÉTIQUE</A><DD>
<DT><A HREF="#lbBR">EXPRESSIONS CONDITIONNELLES</A><DD>
<DT><A HREF="#lbBS">DÉVELOPPEMENT DES COMMANDES SIMPLES</A><DD>
<DT><A HREF="#lbBT">EXÉCUTION DES COMMANDES</A><DD>
<DT><A HREF="#lbBU">ENVIRONNEMENT D'EXÉCUTION DES COMMANDES</A><DD>
<DT><A HREF="#lbBV">ENVIRONNEMENT</A><DD>
<DT><A HREF="#lbBW">CODE DE RETOUR</A><DD>
<DT><A HREF="#lbBX">SIGNAUX</A><DD>
<DT><A HREF="#lbBY">CONTRÔLE DES JOBS</A><DD>
<DT><A HREF="#lbBZ">SYMBOLE D'ACCUEIL (PROMPT)</A><DD>
<DT><A HREF="#lbCA">BIBLIOTHÈQUE READLINE</A><DD>
<DL>
<DT><A HREF="#lbCB">Notation Readline</A><DD>
<DT><A HREF="#lbCC">Initialisation de Readline</A><DD>
<DT><A HREF="#lbCD">Affectation des touches de Readline</A><DD>
<DT><A HREF="#lbCE">Variables de Readline</A><DD>
<DT><A HREF="#lbCF">Constructions conditionnelles de Readine</A><DD>
<DT><A HREF="#lbCG">Recherche</A><DD>
<DT><A HREF="#lbCH">Noms des commandes Readline</A><DD>
<DT><A HREF="#lbCI">Commandes de déplacement</A><DD>
<DT><A HREF="#lbCJ">Commandes de manipulation de l'historique</A><DD>
<DT><A HREF="#lbCK">Commande d'édition de texte</A><DD>
<DT><A HREF="#lbCL">Effacement et récupération</A><DD>
<DT><A HREF="#lbCM">Arguments numériques</A><DD>
<DT><A HREF="#lbCN">Complétion</A><DD>
<DT><A HREF="#lbCO">Macros Claviers</A><DD>
<DT><A HREF="#lbCP">Divers</A><DD>
</DL>
<DT><A HREF="#lbCQ">HISTORIQUE</A><DD>
<DT><A HREF="#lbCR">EXPANSION DE L'HISTORIQUE</A><DD>
<DL>
<DT><A HREF="#lbCS">Indicateur d'événement</A><DD>
<DT><A HREF="#lbCT">Indicateurs de mots</A><DD>
<DT><A HREF="#lbCU">Modificateurs</A><DD>
</DL>
<DT><A HREF="#lbCV">COMMANDES INTERNES DU SHELL</A><DD>
<DT><A HREF="#lbCW">SHELL RESTREINT</A><DD>
<DT><A HREF="#lbCX">VOIR AUSSI</A><DD>
<DT><A HREF="#lbCY">FICHIERS</A><DD>
<DT><A HREF="#lbCZ">AUTEURS</A><DD>
<DT><A HREF="#lbDA">RAPPORT DE BOGUE</A><DD>
<DT><A HREF="#lbDB">BOGUES</A><DD>
<DT><A HREF="#lbDC">TRADUCTION</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 14:54:46 GMT, February 11, 2014
</BODY>
</HTML>
